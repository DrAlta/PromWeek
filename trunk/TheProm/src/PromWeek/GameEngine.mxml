<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" 
		 xmlns:prom="PromWeek.*" xmlns:util="com.util.*"
		 preinitialize="onPreinitialize()"
		 initialize="onInitialize()"
		 creationComplete="onCreationComplete()"
		 click.Performance="onClickInPerformanceState(event)"
		 
		 click.LevelObjective="onClickInLevelObjectiveState(event)"
		 currentStateChange="onCurrentStateChange(event)"
		 width="100%"
		 height="100%">		
	<!--click.Results="onClickInResultsState(event)"-->
	<fx:Metadata>
		
	</fx:Metadata>
	
	<fx:Declarations>
		<mx:Fade id="tutorialFilterFadeIn" alphaFrom="0.0" alphaTo="1.0" effectStart="tutorialFilterFadeInStarted(event)"/>
		<mx:Fade id="tutorialFilterFadeOut" alphaFrom="1.0" alphaTo="0.0" effectEnd="tutorialFilterFadeInStopped(event)"/>
		<!--<fx:XML id="testContinueLevelTraceXML" source="../testLevelTrace.xml" />-->
	</fx:Declarations>
	
	<s:states>
		<s:State name="MainMenu"/>
		<s:State name="StorySelection"/>
		<s:State name="OptionsMenu"/>
		<s:State name="AchievementsMenu"/>
		<s:State name="CreditsMenu"/>
		<s:State name="TutorialScreen"/>
		<!-- What is in the LevelObjective state?
		- Background of some kind
		- Textual Description of the objective ("Get Edward to Date Karen")
		- Big 'play now' button-->
		<s:State name="LevelObjective"/>
		<!--
		What is in the Interaction state?
		- CharInfoUI
		- Networks, relationships
		- social game button rings
		- selection circles
		- interaction mouse event handler
		- camera to show entire world
		-->
		<s:State name="Interaction"/>
		<!--
		What to do for the Performance state?
		- all UI elements from the Interaction state
		- add dialog bubbles (manage visibility as part of performance).
		- performance mouse event handler
		- camera to follow social game performers
		-->
		<s:State name="Performance"/>
		<!--
		What to do for the Performance state?
		- Results UI
		- hide dialog bubbles
		- results mouse event handler
		- camera to follow social game performers
		-->
		<s:State name="Results"/>
		<s:State name="Pause"/>
		<!--
		What to do for EndOfLevelResults?onStateC
		-I don't know, write down stuff. I don't know what it would be.
		-->
		<s:State name="EndOfLevelResult" />
		<s:State name="LoadingLevel" />
		<s:State name="EndOfStory" />
		<s:State name="SandboxMenu" />
		<s:State name="FacadeState" />
	</s:states>

	
	<prom:HUDGroup id="hudGroup" width="100%" height="100%" />
	
	<s:Group id="tutorialFilter" visible="false" mouseEnabled="false" mouseChildren="false"> <!--hideEffect="{fadeOut}" showEffect="{fadeIn}"-->
		<util:SmoothImage id="tutorialScreenFilter" mouseEnabled="false" mouseChildren="false" />
	</s:Group>
	
	<prom:TutorialPopup id="tutorialPopup" x="25" y="50" visible="false" />	
	
	<!--<s:VGroup>
		<s:NumericStepper id="cameraX" minimum="-100" maximum="10000" stepSize="1"></s:NumericStepper>
		<s:NumericStepper id="cameraY" minimum="-100" maximum="10000" stepSize="1"></s:NumericStepper>
	</s:VGroup>-->
	
		
	<fx:Script>
		<![CDATA[
		import flash.filters.BlurFilter;
		import flash.filters.ColorMatrixFilter;
		import com.facebook.graph.Facebook;
		import com.facebook.graph.data.FacebookSession;
		import com.facebook.graph.net.FacebookRequest;
		import com.furusystems.dconsole2.plugins.CommandMapperUtil;
		import com.furusystems.dconsole2.plugins.controller.ControlField;
		import com.furusystems.dconsole2.plugins.controller.Controller;
		import com.furusystems.dconsole2.plugins.controller.ControllerManager;
		import com.furusystems.dconsole2.plugins.controller.ControllerUtil;
		import com.furusystems.dconsole2.plugins.inspectorviews.treeview.TreeViewUtil;
		import com.furusystems.dconsole2.plugins.StatsOutputUtil;
		import org.flintparticles.twoD.renderers.BitmapRenderer;
		import flash.display.Stage;
		import flash.events.FullScreenEvent;
		import flash.external.ExternalInterface;
		import net.keithhair.managers.KeyManager;
		import com.greensock.TweenLite;
		import flash.display.DisplayObject;
		import flash.media.SoundTransform;
		import flash.utils.Dictionary;
		import mx.controls.RichTextEditor__embed_mxml_assets_icon_style_bold_png_1650193410;
		import mx.managers.ToolTipManager;
		import flash.events.Event;
		import flash.events.KeyboardEvent;
		import flash.events.MouseEvent;
		import PromWeek.skins.NEW_listScrollSkin;
		import spark.components.Application;
		import spark.components.HGroup;
		//import flash.events.WeakFunctionClosure;
		import flash.geom.Point;
		import flash.geom.Rectangle;
		import flash.geom.Vector3D;
		import flash.media.Sound;
		import flash.media.SoundChannel;
		import flash.text.TextField;
		import flash.text.TextFormat;
		import flashx.textLayout.property.NumberWithEnumProperty;
		import mx.core.UIComponent;
		import mx.events.StateChangeEvent;
		import PromWeek.skins.PromWeekToolTipBorder;
		import spark.components.Group;
		import mx.controls.Image;  import com.util.SmoothImage;
		import mx.binding.utils.BindingUtils;
		import CiF.*;
		import spark.primitives.Rect;
		import PromWeek.Camera;
		import PromWeek.StatusChangeIcon;
		import spark.components.RichText;
		import spark.primitives.Rect;
		import mx.graphics.SolidColor;
		import mx.graphics.SolidColorStroke;
		import PromWeek.assets.ResourceLibrary;
		import PromWeek.assets.SoundLibrary;
		import com.furusystems.dconsole2.DConsole;
		import mx.controls.Alert;
		import PromWeek.assets.SoundLibrary;
		import spark.components.List;
		import com.adobe.utils.StringUtil;
		
		public static const deemphasizedAlpha:Number = 0.5;
		
		public var aaronTestMode:Boolean = false;
		
		public var useConsoleButton:Boolean = false; // has the button that brings up the console appear.
		
		public var tutorial:PromWeek.Tutorial;
		public var tutorialStopped:Boolean;
		public var useEndingButtons:Boolean = false;
		public var useUseDifferentCharacterWarning:Boolean = false;
		
		/**
		 * Various Debug Things that we can turn on and off as we need them.
		 * They used to live all over the place, now they live here, in game engine.
		 */
		//Lots of flags for 'big info dumps' on social game buttons tool tips
		public var toolTipShowsAcceptReject:Boolean = true;
		public var toolTipShowEffectChangePredicates:Boolean = true;
		public var toolTipShowMotives:Boolean = true;
		public var toolTipShowForecast:Boolean = false;
		
		
		public var facadeState:Boolean = false;
		
		public var useBetweenTurnHints:Boolean = false;
		public var useJuicePoints:Boolean = true; // enables the entire juice points system.
		
		public var doesPlayerHaveChoiceOfSGOutcome:Boolean = true; // if true, shift clicking on a social game lets you decide the outcome, if false, it just does the opposite of how they would have responded.
		
		public var dropDownListShouldDisplay:Boolean = true; // the drop down list with the social game button ring that contians every single possible game.
		
		
		public var tutorialFilterFollowing:DisplayObject;
		public var tutorialFilterFollowingWidth:Number;
		public var tutorialFilterFollowingHeight:Number;
		
		public var filterOffsetX:Number = -2000;
		public var filterOffsetY:Number = -2000;
		
		public var currentSetOfSocialGames:Vector.<SocialGame>;
		
		public var socialGameContext:SocialGameContext;
		
		public var isCurrentContinued:Boolean = false;
		
		public var continueLevelTraceXML:XML;
		public var freeplayLevelTraceXML:XML;
		
		public var getContinueLevelTrace:Boolean = true;
		public var getFreeplayLevelTrace:Boolean = true;
		
		/**
		 * Possible booleans for dynamically changing colors
		 */
		public var classicPromColors:Boolean = true;
		public var greenPromColors:Boolean;
		public var redPromColors:Boolean;
		
		public var activeStyleName:String = "classicPromWeek";
		/**
		 * Common theme colors.
		 * 
		 * text color for romance: 0xe40076
		 * 
		 */
		public static const BUDDY_COLOR:Number = 0x00FF00;
		public static const ROMANCE_COLOR:Number = 0xFF99CE;
		public static const COOL_COLOR:Number = 0x0000ff;
		
		/*
		public static const BUDDY_SELECTED_COLOR:Number = ;
		public static const ROMANCE_SELECTED_COLOR:Number = ;
		public static const COOL_SELECTED_COLOR:Number = ;
		*/
		
		public static const DEFAULT_BLUE:Number = 0x3B7BFF;
		public static const DEFAULT_BORDER:Number = 0x000000;
		
		public static const ENDING_DEFAULT:Number = 0x3B7BFF;
		public static const ENDING_HOVER:Number = 0x3B7BFF;
		public static const ENDING_DOWN:Number = 0x3B7BFF;
		
		/*
		 * This is used to toggle whether the minimap functionality is active or not
		 */
		public var MINI_MAP:Boolean = false;
		
		public var isDConsoleActive:Boolean = true;
		public var uiComponent:UIComponent;
		
		public static const UTTERANCE_FREQUENCY:Number = 0.4;
		public static const IDLE_MOVEMENT_FREQUENCY:Number = 0.001;
		public static const MIN_SUBJECTIVE_OPINION_CHANGE_FOR_ANIMATION:Number = 0.15;
		
		
		public static const SSU_THRESHOLD:Number = 5;
		
		public static const MIN_SSU_UPDATE_TIME_IN_LEVEL:Number = 60000;
		public static const MAX_SSU_UPDATE_TIME_IN_LEVEL:Number = 180000;
		public static const MIN_SSU_UPDATE_TIME_NOT_IN_LEVEL:Number = 240000;
		public static const MAX_SSU_UPDATE_TIME_NOT_IN_LEVEL:Number = 500000;

		
		
		public var startOfSocialExchangePerformance:Number;
		public var lengthOfSocialExchangePerformance:Number;
		
		public var tutorialDisallowBackgroundClicks:Boolean = false;
		

		
		/**
		 * The xml representation of the time 0 starting state.
		 */
		public var intitialState:XML;
		 
		/**
		 * The default XML representation of the time 0 starting state.
		 * Individual stories can have their own start states (and those get stored in gameEngine.intitialState (note the typo -- it is intentional I guess).
		 * However, if a story does not specify their own start state, then we will use this default state instead.
		 */
		public var defaultState:XML;
		
		/**
		 * The xml representation of the time 0 starting state.
		 * FOR TUTORIALS
		 */
		public var intitialStateForTutorials:XML;
	
		/**
		 * Variables used by the social game buttons to populate the megaUI
		 */
		public var currentlySelectedSG:String;
		public var currentlySelectedInitiator:String;
		public var currentlySelectedResponder:String;
		
		
		
		/**
		 * This hold all the endings that are available to be played;
		 */
		public var possibleEndings:Vector.<Ending>;
		public var endingIndex:int;
		
		/**
		 * Variables used to time how long total intent formation takes
		 */
		public var intentTime:Number;
		public var startIntentTime:Number;
		
		public var consoleFormIntent:Boolean = false; // please keep this false! Even if not using the console, your life will be better if this stays false.
		
		public var negateResponderScore:Boolean = false; // if they activate a secret code, negate the responder's score (+ becomes -, - becomes +);
		//click and drag camera configuration
		/**
		 * The worldgroup space per second to translate the camera.
		 */
		public var panSpeed:Number = 350.0;
		/**
		 * Inverted pan. True if click and drag to the right moves the bg to the right.
		 */
		public var invertedPan:Boolean = true;
		public var enableDragPanning:Boolean = true;
		public var enableSidePanning:Boolean = false;
		
		private static var _instance:GameEngine = new GameEngine();
		//private static var _instance:GameEngine;
		
		//private var cif:CiFSingleton = CiFSingleton.getInstance();
		private var cif:CiFSingleton = CiFSingleton.getInstance();
		private var dm:DifficultyManager;
		private var jpm:JuicePointManager;
		private var statisticsManager:StatisticsManager;
		private var visibilityManager:VisibilityManager;
		
		private var resourceLibrary:PromWeek.assets.ResourceLibrary;
		private var soundLibrary:SoundLibrary;
		
		public var soundChannel:SoundChannel;
		public var soundVolume:Number = 0.75;
		public var soundFXTransform:SoundTransform = new SoundTransform(0.75);
		public var isSoundOn:Boolean = true;
		
		private var backend:Backend = new Backend();
		
		/**
		 * True if all of the xml has been loaded into CiF and the GameEngine wrt authoring.
		 */
		public var isAuthoringLoaded:Boolean = false;
		
		public var firstIntentHasBeenFormed:Boolean = false;
		
		//[Bindable]
		public var worldGroup:PromWeek.WorldGroup;
		
		public var miniMap:PromWeek.MiniMap;

		
		/**
		 * The height and width of the application.
		 */
		public var worldGroupScale:Number;
		public var APPLICATION_WIDTH:Number=758;
		public var APPLICATION_HEIGHT:Number=600;
		public var APPLICATION_SCALE:Number=1.0;
		
		public var debugMode:Boolean = true;	
		
		private var scenarioDescription:ScenarioDescription;
		
		public var gentleFadeFlag:Boolean = false; // used for fading out the Level Objective Screen
		public var shouldAcceptNormalKeyboardInput:Boolean = true;
		
		private var lastTimeStamp:Number;
		private var frameCount:int;
		
		public var camera:PromWeek.Camera;
		
		public var socialGameToPerform:String;
		
		public var endingToPerform:Ending;
		public var endingPlaying:Boolean = false;
		
		[Bindable]
		public var _primaryAvatarSelection:String = null;
		
		[Bindable]
		public var _secondaryAvatarSelection:String = null;
		public var currentNetworkSelection:String = "buddy";
		
		public var finishedLoading:Boolean = false;
		
		//public var soundChannel:SoundChannel;
		
		public var initiatorName:String;
		public var responderName:String;
		public var otherName:String;
		
		/**
		 * The current rounds of social game play left on the level.
		 */
		public var levelTime:Number = 0;
		
		public var socialGamePlaying:Boolean = false;
		
		public var dialougeLineNumber:int = 0;
		
		public var currentDialogueInstantiation:Instantiation;
		public var currentLoDPartialChangeDealtWithYet:Vector.<Boolean>;
		
		public var responderArrived:Boolean = false;
		public var initiatorArrived:Boolean = false;
		public var otherArrived:Boolean = false;
		public var otherDeparted:Boolean = false;
		
		//if true, it means that we always want the star of the story to be in the middle of the level. If false, they get re-adjusted like normal people.
		public var STAR_SHOULD_ALWAYS_BE_IN_MIDDLE:Boolean = false;
		
		
		
		//These are set by the hudGroup when the player scrolls over to the far left or right of the screen
		public var scrollWorldGroupRight:Boolean = false;
		public var scrollWorldGroupLeft:Boolean = false;
		public var scrollWorldGroupDown:Boolean = false;
		public var scrollWorldGroupUp:Boolean = false;
		public var worldGroupScrollSpeed:Number = 0.2;
		
		public var initiatorPerformanceLocationX:Number = 550;
		public var initiatorPerformanceLocationY:Number = 350;

		public var responderPerformanceLocationX:Number = 750;
		public var responderPerformanceLocationY:Number = 350;
		
		public var otherPerformanceLocationX:Number = 650;
		public var otherPerformanceLocationY:Number = 250;
		
		
		private var performanceLocY:Number;
		private var performanceLocX:Number;
		private var performanceZoom:Number = 0.85;
		private var otherPerformanceZoom:Number = 0.8; // Let's use a different zoom if the scene requires an other!
		private var performanceHorizontalOffset:Number;
		private var performanceCameraX:Number;
		private var performanceCameraY:Number;
		private var tempCameraX:Number /* takes into account weird offset hackey-ness -- helps with teleport in other */
		private var tempCameraY:Number /* takes into account weird offset hackey-ness -- helps with teleport in other */
		
		private var titleMusicFirstTime:Boolean;
		
		// sets the maximum number of AutonomousActionNotifier objects to be shown!
		public static var MAXIMUM_AUTONOMOUS_NOTIFICATIONS:Number = 2;
		// Set this to true or false whether or not you want ONLY RELATIONSHIP INTENT games or all games for AAN!
		public static var AUTONOMOUS_RELATIONSHIP_ONLY:Boolean = false;
	
		public var currCharForIntent:int = 0;
		 
		/**
		 * The stories avaible to The Prom loaded from XML;
		 */
		public var stories:Vector.<Story>;
		
		/**
		 * The list of achievements in the game.
		 */
		public var achievements:Vector.<Achievement>;
		
		/**
		 * The active story.
		 */
		public var currentStory:Story;
		
		/**
		 * The active level;
		 */
		public var currentLevel:Level;
		
		/**
		 * The index of the current level in the vector of levels contained in the story.
		 */
		public var currentLevelIndex:Number;
		
		/**
		 * this.levelStartedTime
		 */
		public var levelStartedTime:Number;
		
		public var timeBeforeEndingsAreAvailable:int = 0;
		 
		/**
		 * True if the either the player or the game engine has signified that
		 * the next level in the story is to be loaded.
		 */
		public var isLevelFinished:Boolean = false;
		
		/**
		 * True if the level's goals are satisfied.
		 */
		public var areLevelGoalsSatisfied:Boolean = false;
		
		
		/**
		 * True if character intent is being formed after the social state is changed.
		 */
		public var isFormingIntent:Boolean = false;
		
		/**
		 * Level cast index iterators to help with interleaving the ccomputation
		 * in the form intent process with the onEnterFrame updates.
		 */
		public var intentInitiatorIterator:Number;
		public var intentResponderIterator:Number;
		public var intentSGIterator:Number;
		
		public var latestInitiatorPredicateRelevance:Vector.<RuleRecord>;
		public var latestResponderPredicateRelevance:Vector.<RuleRecord>;
		
		public var latestInitiatorInfluenceRules:Vector.<String>;
		public var latestResponderInfluenceRules:Vector.<String>;		
		
		public var currentLineOfDialogueStartTime:Number;
		
		/**
		 * These are used to time when social status updates are made
		 */
		public var timeTillNextSocialStatusUpdate:Dictionary;
		public var timeOfLastSocialStatusUpdate:Dictionary;
		
		public var displayGoalProgressNotifications:Boolean = false;
		
		public var gameXML:XML;
		
		public static var _getInstanceCount:int = 0;
		
		public var showTestLevel:Boolean = false;
		public var endingPickedPairs:Vector.<Dictionary>;
		
		/**
		 * This limits which avatars can be pressed in the tutorial
		 */
		public var tutorialAvatarName:String;
		public var useLevelObjectiveScreen:Boolean = false;

		public var currentTutorialStep:TutorialStep;
		public var MIN_DANCE:Number = 12000;
		public var MAX_DANCE:Number = 25000;
		
		public var responsePhrases:Dictionary;
		public var lastRecenterTime:Number = 0;
		public var pendingSSUs:Vector.<Object> = new Vector.<Object>();
		public var timeOfLastSSU:Number = 0;
		
		public static function getInstance():GameEngine {
			if(PromWeek.GameEngine._getInstanceCount < 1) 
				Debug.debug(GameEngine, "getInstance()");
			PromWeek.GameEngine._getInstanceCount++;
			return _instance;
			//return this;
		}
		

		
		
		private function onPreinitialize():void {
			Debug.debug(this, "onPreinitialize()");
			
			//PromWeek.GameEngine._instance = this;

			resourceLibrary = PromWeek.assets.ResourceLibrary.getInstance();
			soundLibrary = SoundLibrary.getInstance();
			Setting.initializeSettingsData()
			// create and initialize social status update things
			timeTillNextSocialStatusUpdate = new Dictionary();
			timeOfLastSocialStatusUpdate = new Dictionary();
			
			//ExternalInterface.addCallback("fullScreen", this.fullScreen);
		}
		
		override protected function commitProperties():void {
			Debug.debug(this, "commitProperties()");
			super.commitProperties();
			this.width = this.APPLICATION_WIDTH;
			this.height = this.APPLICATION_HEIGHT;
			
			
			if (this.hudGroup && this.worldGroup && this.camera) 
			{
				//	hudGroup.setDimensions(this.APPLICATION_WIDTH, this.APPLICATION_HEIGHT);
				
				this.hudGroup.setScale(this.APPLICATION_SCALE);
				
				this.worldGroupScale = 0.8 //* this.APPLICATION_SCALE;
				camera.setWindowDimensions(this.APPLICATION_HEIGHT, this.APPLICATION_WIDTH);
				
				var scaledWidth:Number = this.APPLICATION_WIDTH + 10;//this.hudGroup.width * this.hudGroup.getScale() + 10;
				this.hudGroup.topBar.pathData = "M -5 -5 l " + scaledWidth + " 0 l 0 40 l " + ( -1 * (scaledWidth - 150)) + " 0 C 107 77 36 72 -4 52 l 0 -55";
				this.hudGroup.topBar.width = this.APPLICATION_WIDTH;
				this.hudGroup.topBar.juiceBar.invalidateProperties();
				this.hudGroup.topBar.juiceBar.updateOnResize(jpm.currentJuicePoints);

				//this.hudGroup.intentProgressBar.right = 10; 
				
				//this.tutorial.positionPopUpWindow();
				//this.hudGroup.endingInfoWindow.x = this.APPLICATION_WIDTH - this.hudGroup.endingInfoWindow.width - 10;
				//this.hudGroup.endingInfoWindow.y = this.APPLICATION_HEIGHT - this.hudGroup.endingInfoWindow.height - 10;
			}
			
			Debug.debug(this, "commitProperties() this <" + this.width + ", " + this.height + ", " + this.scaleX + "> app: <" + this.APPLICATION_WIDTH+ ", " + this.APPLICATION_HEIGHT+ ", " + this.APPLICATION_SCALE+ ">");
			Utility.log(this, "commitProperties() this <" + this.width + ", " + this.height + ", " + this.scaleX + "> app: <" + this.APPLICATION_WIDTH+ ", " + this.APPLICATION_HEIGHT+ ", " + this.APPLICATION_SCALE+ ">");
		}
		
		
		override protected function createChildren():void {
			Debug.debug(this, "createChildren()");

			//doomsday console plugin registration
			CONFIG::monster {
				DConsole.registerPlugins(StatsOutputUtil);
				DConsole.registerPlugins(ControllerUtil);
				DConsole.registerPlugins(CommandMapperUtil);
				//DConsole.registerPlugins(ChainsawConnectorUtil);
				DConsole.registerPlugins(ControllerManager);
			}			
			
			//var debug:DebugGroup = new DebugGroup();
			//this.hudGroup.addElement(debug);
			//debug.top = 100.0;
			//debug.left = 0.0;
			
			super.createChildren();
		}
		
		public function onInitialize():void {
			Debug.debug(this, "onInitialize()");

			
			
			// worldGroups only exist after a level has been loaded
			// this.worldGroup.scaleX = PromWeek.GameEngine.getInstance().worldGroupScale;
			// this.worldGroup.scaleY = PromWeek.GameEngine.getInstance().worldGroupScale;
			
			//debug.createCameraVisualization();
			this.currentState = "MainMenu"; // Now that we have tutorials, I think it makes more sense to make the main menu the start screen.
			
			this.addEventListener(Event.ENTER_FRAME, this.onEnterFrame);
			//this.addEventListener("CLICKED_ON_INITIATORSELECTEDCOMPONENT", onClickOnInitiatorSelectedComponent);
			this.hudGroup.juiceBar.setCursor(hudGroup.jpm.currentJuicePoints)
			this.hudGroup.topBar.juiceBar.setCursor(hudGroup.jpm.currentJuicePoints)
			this.styleToolTips();
		}
		
		//private function onClickOnInitiatorSelectedComponent(e:MouseEvent):void
		//{
			//trace("ffff");
			//this.dispatchEvent(e);
		//}
		
		public function set primaryAvatarSelection(name:String):void
		{
			if(visibilityManager != null) visibilityManager.newAvatarClicked(_primaryAvatarSelection, name, true);
			this._primaryAvatarSelection = name;
		}
		public function get primaryAvatarSelection():String
		{
			return this._primaryAvatarSelection;
		}
		
		public function set secondaryAvatarSelection(name:String):void
		{
			if(visibilityManager != null) visibilityManager.newAvatarClicked(_primaryAvatarSelection, name, false);
			this._secondaryAvatarSelection = name;
		}
		public function get secondaryAvatarSelection():String
		{
			return this._secondaryAvatarSelection;
		}


		
		
		
		public function styleToolTips():void {
			//Class(PromWeekToolTipBorder).setStyleName();
			//Class(PromWeekToolTipBorder).styleName = this.activeStyleName;
			//Class(PromWeekToolTipBorder).styleChanged("styleName");
			styleManager.getStyleDeclaration("mx.controls.ToolTip").setStyle("color",this.getStyle("textColor"));
			//return; //XXXXXXXXXXXXXXXXXXXXXX
			//styleManager.getStyleDeclaration("mx.controls.ToolTip").setStyle("fontStyle","italic");
			//styleManager.getStyleDeclaration("mx.controls.ToolTip").setStyle("fontSize","19");
			//styleManager.getStyleDeclaration("mx.controls.ToolTip").setStyle("fontFamily","Arial");
			
			//styleManager.getStyleDeclaration("mx.controls.ToolTip").setStyle("backgroundColor",this.getStyle("contentAreaColor"));
			
			//var cssDecl:CSSStyleDeclaration = StyleManager.getStyleDeclaration("mx.controls.ToolTip");
			//var cssDecl:CSSStyleDeclaration = StyleManager.getStyleDeclaration("mx.controls.ToolTip");
			//if (!cssDecl) {
				//cssDecl = new CSSStyleDeclaration("mx.controls.ToolTip");
				//cssDecl = new CSSStyleDeclaration("mx.controls.ToolTip");
			//}
			//cssDecl.setStyle("backgroundAlpha", 1.0);
			//cssDecl.setStyle("backgroundColor", this.getStyle("contentAreaColor"));
			//cssDecl.setStyle("color", this.getStyle("textColor"));
			//cssDecl.setStyle("borderColor", this.getStyle("contentAreaStrokeColor"));
			//cssDecl.setStyle("cornerRadius", 2);
			
		}
		
		public function tutorialFilterClicked(e:MouseEvent):void
		{
			this.dispatchEvent(new MouseEvent(MouseEvent.CLICK, true, false));
		}
		
		public function onCreationComplete():void {
			//Debug.debug(this, "onCreationComplete()");

			tutorialScreenFilter.source = ResourceLibrary.getInstance().uiIcons["tutorialFilter"];
			tutorialFilter.addEventListener(MouseEvent.CLICK, tutorialFilterClicked);
			
			
			
			this.currentSetOfSocialGames = cif.socialGamesLib.games;
			/*
			this.currentSetOfSocialGames = new Vector.<SocialGame>();
			this.currentSetOfSocialGames.push(cif.socialGamesLib.getByName("ask out"));
			this.currentSetOfSocialGames.push(cif.socialGamesLib.getByName("woo"));
			this.currentSetOfSocialGames.push(cif.socialGamesLib.getByName("share interest"));
			this.currentSetOfSocialGames.push(cif.socialGamesLib.getByName("confide in"));
			this.currentSetOfSocialGames.push(cif.socialGamesLib.getByName("bully"));
			*/
			
			this.possibleEndings = new Vector.<Ending>();
			
			ToolTipManager.showDelay = 0;// Display immediately.
			ToolTipManager.hideDelay = 100000; // Hide after 10 seconds of being viewed.
			
			jpm = JuicePointManager.getInstance();
			statisticsManager = StatisticsManager.getInstance();
			dm = DifficultyManager.getInstance();
			visibilityManager = VisibilityManager.getInstance();
			
			visibilityManager.useOldInterface = false;
		}
		
	
		
		public function facebookLogin(e:Event = null):void
		{
			// create facebook connection if an app id is specified
			if (this.gameXML.hasOwnProperty("Config") && this.gameXML.Config.hasOwnProperty("FacebookAppId"))
			{
				Debug.debug(this, "createChildren() facebook connection is required by gameConfig.xml.");
				Utility.log(this, "createChildren() facebook connection is required by gameConfig.xml.");
				// initialize API
				try {
					var facebookAppID:String = this.gameXML.Config.FacebookAppId.toString()
					Utility.log(this, "createChildren() about to call Facebook.init(). FacebookAppID: " + facebookAppID);
					
					var options:Object = { status: true, cookie: true, oath: true };
					
					//Facebook.init(this.gameXML.Config.FacebookAppId, this.facebookInitCallback, options, null, true);
					Debug.debug(this, "facebookLogin() attempting FacebookInit");
					Facebook.init(facebookAppID, this.facebookInitCallback);
				} catch (e:Error) {
					Utility.log(this, "createChildren() error in Facebook.init().");
					trace(e);
					Debug.debug(this, "facebookLogin() failed Facebook init: " + e);
				}
			}
			//try to logon
			//Facebook.login(facebookLoginCallback,{ scope: "email, publish_stream" });	
			
			this.getBackend().getGoalsSeen(this.getBackend().getFacebookId());
		}
		
		
		public function facebookInitCallback(success:Object, fail:Object):void {
			//Debug.debug(this, "****************************************do I even get here?");
			//Debug.debug(this, "****************************************Hello?!?");
			// saves facebook id to backend object and increases unique playcount
			Utility.log(this, "facebookInitCallback() entered.");
			Debug.debug(this, "facebookInitCallback() entered.");
			if (success && success.accessToken) {
				this.saveFacebookId(success, fail);
				
				this.getBackend().getEndingsSeen(this.getBackend().getFacebookId());
				//Let us see if this is a good place to call backend.getEndings.
				//Debug.debug(this, "****************************************facebookInitCallback)");
				//Debug.debug(this, "****************************************Hello?!?");
				
				
				//Alert.show("Facebook init success. FBID: " + gameEngine.getBackend().getFacebookId());
				Utility.log(this, "facebookInitCallback() init success! " + success.uid + success.accessToken + success);
			} else {
				Utility.log(this, "facebookInitCallback() init fail.");
				//Alert.show("Facebook init fail. Attempting to Facebook.login.");
				
				//Debug.debug(this, "facebookInitCallback() attempting Facebook.login with saveFacebookId as callback!!!!!");
				//Facebook.login(saveFacebookId, { scope: "email, publish_stream" });
				//Facebook.login(saveFacebookId, { scope: "" });
			}
			this.getBackend().getGoalsSeen(this.getBackend().getFacebookId());
		}
		
		public function saveFacebookId(success:Object, fail:Object):void {
			if (success) {
				this.getBackend().setFacebookId(success.uid);
				this.getBackend().gameLoaded();
				Utility.log(this, "saveFacebookId() " + success.uid + success.accessToken + success);
			}
			else {
				Debug.debug(this, "saveFacebookId() failure");
			}
		}
		
		
		
		
		
		/**
		 * Loads the initial game state from the its original XML representation. This representation
		 * should be linked to the game engine by main.mxml. CiF's time is reset to 0, the SFDB, cast,
		 * social networks, relationships, and statuses are all reset to time=0 values.
		 * 
		 * @return
		 */
		public function resetGameState():void {
			this.cif.time = 0;
			if (currentStory.isQuickPlay) {
				visibilityManager.quickPlayEndingTextHasBeenRendered = false;
				//visibilityManager.quickPlayLevelTextHasBeenRendered = false;
			}
			this.cif.parseCiFState(this.intitialState, false);
			//reform the character references in the level instances.
			for each(var s:Story in this.stories) {
				for each(var l:Level in s.levels) {
					l.refreshCast();
				}
			}
			cif.clearProspectiveMemory();
		}
		
		/**
		 * Loads the tutorial game state from the its original XML representation. This representation
		 * should be linked to the game engine by main.mxml. CiF's time is reset to 0, the SFDB, cast,
		 * social networks, relationships, and statuses are all reset to time=0 values.
		 * 
		 * @return
		 */
		public function resetGameStateForTutorial():void {
			this.cif.time = 0;
			this.cif.parseCiFState(this.intitialStateForTutorials, false);
			//reform the character references in the level instances.
			for each(var s:Story in this.stories) {
				for each(var l:Level in s.levels) {
					l.refreshCast();
				}
			}
			
		}
		
		/**
		 * Restarts the current story at the first level and resets the gameplay
		 * time to 0 -- a fresh game state.
		 */
		public function resetStory():void {
			this.resetGameState();
			this.activateLevel(0);
		}
		
		public function tutorialFilterFadeInStarted(e:Event):void
		{
			this.tutorialFilter.visible = true;
		}
		public function tutorialFilterFadeInStopped(e:Event):void
		{
			this.tutorialFilter.visible = false;
		}		
		
		
		/**
		 * Returns the backend
		 */
		public function getBackend():Backend
		{
			return this.backend;
		}
		
		/**
		 * Set API base url for backend
		 * @param baseURL Base URL of the API, e.g. http://promweek.com/api
		 */
		public function initializeBackend(baseURL:String):void
		{
			this.backend.setBaseURL(baseURL);
		}
		
		
		public function initializeGameEngine():void
		{	
			Debug.debug(this, "initializeGameEngine()");

			camera = new PromWeek.Camera();
			
			/*mx.binding.utils.BindingUtils.bindProperty(this.camera.destinationInWorldCoordinates, "x", this.cameraX, "value");
			mx.binding.utils.BindingUtils.bindProperty(this.cameraX, "value", this.camera.destinationInWorldCoordinates, "x");
			mx.binding.utils.BindingUtils.bindProperty(this.camera.destinationInWorldCoordinates, "y", this.cameraY, "value");
			mx.binding.utils.BindingUtils.bindProperty(this.cameraY, "value", this.camera.destinationInWorldCoordinates, "y");*/
			this.frameCount = 0;
			this.lastTimeStamp = new Date().time;
			
			
			
			var charOffsetX:Number = 170;
			var charOffsetY:Number = 550;
			var verticalSpaceBetweenRows:Number = 50;
			
			
			//TODO
			//FIXME
			//XXX
			//there's some magic here that we need to capture more generally
			switch (this.currentLevel.settingName.toLowerCase()) {
				case "cornerstoreXXX":
					charOffsetX = 170;
					//charOffsetY = 550;
					performanceHorizontalOffset = 200;
					performanceLocX = 500 ;
					performanceLocY = 950;
					performanceCameraX = 325;
					performanceCameraY = 750;
					performanceZoom = 1.0;
					break;
				case "lockers":
					charOffsetX = -50;
					//charOffsetY = 400;
					performanceHorizontalOffset = 200;
					performanceLocX = 500 ;
					performanceLocY = 850;
					performanceCameraX = 325;
					performanceCameraY = 650;
					performanceZoom = 1.0;
					break;
				default:
					charOffsetX = -50;
					//charOffsetY = 400;
					performanceHorizontalOffset = 200;
					performanceLocX = 500 ;
					performanceLocY = 850;
					performanceCameraX = 325;
					performanceCameraY = 650;
					performanceZoom = 1.0;
			}
			//performanceZoom  = 1.0;
		
			
			initiatorPerformanceLocationX += charOffsetX;
			initiatorPerformanceLocationY += charOffsetY + 200;
			
			responderPerformanceLocationX += charOffsetX;
			responderPerformanceLocationY += charOffsetY + 200;
			
			//TODO: Figure out if these are good offsets for others.
			otherPerformanceLocationX += charOffsetX;
			otherPerformanceLocationX += charOffsetY + 4000;
		}
		
		
		
		
		
		public function onEnterFrame(e:Event):void 
		{
			//Debug.debug(this, "onEnterFrame()");

			//handle frame and computation weaving of forming intent during results state
			//trace(this.currentState + " " + this.isFormingIntent);
			
			
			// Update the position of the tutorialFilter if it is supposed to be on
			// and we have an object set to follow
			if (this.tutorialFilter.visible && this.tutorialFilterFollowing)
			{
				//var pt:Point = tutorialFilterFollowing.localToGlobal(new Point(tutorialFilterFollowingWidth, tutorialFilterFollowingHeight));
				var pt:Point = Utility.translatePoint(new Point(tutorialFilterFollowingWidth, tutorialFilterFollowingHeight), tutorialFilterFollowing, this);
				this.tutorialFilter.x = pt.x + this.filterOffsetX;
				this.tutorialFilter.y = pt.y + this.filterOffsetY;
			}
			
			if (this.currentState == "LevelObjective" && this.isFormingIntent) {
				Debug.debug(this,  "onEnterFrame() formIntent[" + this.intentInitiatorIterator + ", " + this.intentResponderIterator + ", "+ this.intentSGIterator + "]");
			}
			
			if (this.camera) {
				this.worldGroup.x = this.camera.leftInWorldCoordinates;
				this.worldGroup.y = this.camera.topInWorldCoordinates;
				this.worldGroup.scaleX = this.camera.currentZoom * this.APPLICATION_SCALE;
				this.worldGroup.scaleY = this.camera.currentZoom * this.APPLICATION_SCALE;
				//this.cameraX.value = this.camera.destinationInWorldCoordinates.x;
				//this.cameraY.value = this.camera.destinationInWorldCoordinates.y;
				
			}
			
			if (MINI_MAP)
			{
				if (this.miniMap && this.worldGroup && this.hudGroup) {
					this.miniMap.wWidth = this.worldGroup.currentSetting.viewableWidth;
					this.miniMap.wHeight = this.worldGroup.currentSetting.viewableHeight;
					this.miniMap.wX = this.worldGroup.x;
					this.miniMap.wY = this.worldGroup.y;
					this.miniMap.wScaleX = this.worldGroup.scaleX;
					this.miniMap.wScaleY = this.worldGroup.scaleY;
					this.miniMap.hX = this.hudGroup.x;
					this.miniMap.hY = this.hudGroup.y;
					this.miniMap.hHeight = this.hudGroup.height;
					this.miniMap.hWidth = this.hudGroup.width;
					this.miniMap.hScaleX = this.hudGroup.scaleX;
					this.miniMap.hScaleY = this.hudGroup.scaleY;
				}
			}
			
			if (((this.currentState == "Interaction" || this.currentState == "Results" || this.currentState == "LevelObjective" || this.currentState == "LoadingLevel" || this.consoleFormIntent) && this.isFormingIntent)) {// || !this.firstIntentHasBeenFormed) {
				
				if (this.intentSGIterator >= this.currentSetOfSocialGames.length) {
					this.intentSGIterator = 0;
					this.intentResponderIterator++;
				}
				if (this.intentResponderIterator >= this.currentLevel.cast.length) {
					this.intentResponderIterator = 0;
					this.intentInitiatorIterator++;
				}
				if (this.intentInitiatorIterator >= this.currentLevel.cast.length) {
					//we should be done with this state is reached
					dm.encourageStoryLeadCharacterToAccomplishGoalsBasedOnDifficulty();
					this.isFormingIntent = false;
					this.consoleFormIntent = false;
					
					this.hudGroup.intentProgressBar.visible = false;
					//this.currentState = "Interaction";
					
					if (!this.firstIntentHasBeenFormed)
					{
						this.hudGroup.storyGoalWindow.toDoItemAccordion.updateToDoList(true);
						
						
						Debug.debug(this,"First intent has now been formed");
						this.firstIntentHasBeenFormed = true;
						
						this.camera.centerOnAllCharacters();
						
						this.hudGroup.storyGoalWindow.toDoItemAccordion.updateToDoList(true);
						

						
						//fill in the subjective opinions!
						this.updatePresentCharacterSubjectiveOpinions();
						
						if (this.currentStory.isQuickPlay)
						{
							//this is where we should start our quickplay
							this.hudGroup.quickPlayInstructionsText.populateQuickPlayInstructions(this.currentStory.quickPlayDescription);
						}
						
						if (this.useLevelObjectiveScreen)
						{
							hudGroup.levelObjectiveScreen.clickToBegin.visible = true;
						}

						//set the next button visible if we have formed first intent
						if (this.currentTutorialStep)
						{
							if (this.currentTutorialStep.nextVisible == "true")
							{
								this.tutorialPopup.nextButton.visible = true;
							}
						}
						this.initializeAllSSUTimes();
						
						//if the game is continued, we need to set the level started time to that of the previous trace
						//and not the current cif time.
						if (this.isCurrentContinued) {
							//get the appropriate start time from the correct game mode level trace
							if (this.currentLevel.isSandbox) {
								Utility.log(this, "setting levelStartedTime as freeplay with time 0");
								this.levelStartedTime = 0;
							} else {
								if(this.continueLevelTraceXML.@type == "endOfLevel") {
									//if the last trace was of type "endOfLevel", the start time is the end time of the last trace.
									this.levelStartedTime = this.continueLevelTraceXML.@endTime;
									Utility.log(this, "setting levelStartedTime as a continued story of type endOfLevel with time " + this.levelStartedTime);
								}else{ 
									//otherwise the levelstartedtime is that of the start time of the stored trace
									this.levelStartedTime = this.continueLevelTraceXML.@startTime;
									Utility.log(this, "setting levelStartedTime as a continued story with time " + this.levelStartedTime);
								}
								
							}
						}else {
							this.levelStartedTime = cif.time;
							Utility.log(this, "setting levelStartedTime as a new story with time " + this.levelStartedTime);
						}
						
						//this.hudGroup.promTimeClock.visible = true;
						//for each (var ending:Ending in currentStory.endings)
						//{
							//this.hudGroup.addEndingButton(ending.name);
						//}
					}
					
					this.hudGroup.postSGSFDBEntry.continueButton.enabled = true;
					
					this.intentTime = new Date().time - this.startIntentTime;
					Debug.debug(this, "It took " + this.intentTime + " to form complete intent for " + this.currentLevel.cast.length + " characters.");
					
					// now I want to see if any characters *want* to go autonomously play a game
				}
				if (this.isFormingIntent) {
					//Debug.debug(this, "isformingintent() got here!");
					var initiator:Character = this.currentLevel.cast[this.intentInitiatorIterator];
					var responder:Character = this.currentLevel.cast[this.intentResponderIterator];
					
					//testing something...
					initiator = cif.cast.getCharByName(initiator.characterName);
					responder = cif.cast.getCharByName(responder.characterName);
					
					//var sg:SocialGame = this.cif.socialGamesLib.games[this.intentSGIterator];
					
					//if (initiator.characterName.toLowerCase() == "zack") {
						//Debug.debug(this, "debugging...");
					//}
					
					if (initiator.characterName != responder.characterName) 
					{
						//Debug.debug(this, "and now getting here!");
						this.cif.inititializeMicrotheoryCache();
						//this.cif.clearProspectiveMemory();
						//this.cif.formIntentForSocialGames(initiator, responder, this.currentLevel.cast,this.currentSetOfSocialGames);
						var castToUse:Vector.<Character>;
						//if (this.currentStory.storyLeadCharacter == "Zack" || this.currentStory.storyLeadCharacter == "Chloe")
						if (this.currentStory.title == "QP6")
						{
							castToUse = this.currentLevel.cast;
						}
						else
						{
							castToUse = cif.cast.characters;
						}
						this.cif.formIntentForSocialGames(initiator, responder, castToUse,this.currentSetOfSocialGames);
					}
					
					this.intentResponderIterator++;
					//this.intentSGIterator++;
					setTimeout(hudGroup.intentProgressBarUpdate, 2000);
					
					hudGroup.numCharsProcessed++;
					hudGroup.intentProgressBarUpdate();
				}
			}
			else if (this.currentState == "Results")
			{	
				if (hudGroup.socialGameResultsUI.visible && !hudGroup.socialGameResultsUI.clickToContinueRichText.visible)
				{
					hudGroup.socialGameResultsUI.pleaseWaitRichText.visible = false;
					hudGroup.socialGameResultsUI.clickToContinueRichText.visible = true;
				}
			}
			
			if (this.isLevelFinished) {
				this.isLevelFinished = false;
				
				//Bring up the 'LevelResultsScreen'
				
				if (this.currentLevel.endable)
				{
					this.hudGroup.skipToEndOfNight();
				}
				else
				{
					this.currentState = "EndOfLevelResult";
				}
				
				
				
				//MOVED TO  onClickInEndOfLevelResultState
				//this.activateLevel(this.currentLevelIndex + 1);
				
				this.finishedLoading = false;
				
				
			}
			if (this.currentState == "LoadingLevel") {
			}
			
			if ("EndOfStory" == this.currentState) {
				if (this.currentStory.istutorial) {
					this.tutorial.stopTutorialAndContinueLevel();
				}
			}
			
			//Include states that need the character animation and graphics engine updates are needed
			if (this.currentState == "Interaction" || this.currentState == "Results" || this.currentState == "Performance")
			{	
				var currentTime:Number = new Date().time;
				var elapsedTime:Number = currentTime - this.lastTimeStamp;
				this.frameCount++;
				this.lastTimeStamp = currentTime;

				
				
				if (this.currentState == "Interaction")
				{
					//if we have a responder selected, periodically recenter the camera on them
					if (this.secondaryAvatarSelection != null)
					{
						if ((currentTime - lastRecenterTime) > 2000)
						{
							var locX:Number = this.worldGroup.avatars[this.secondaryAvatarSelection.toLowerCase()].locX;
							var locY:Number = this.worldGroup.avatars[this.secondaryAvatarSelection.toLowerCase()].locY;
							this.camera.absolutePositionCenter(locX, locY, 1.5);							
							lastRecenterTime = currentTime;
						}
					}
					
					
					//this.hudGroup.ssuVisualizer.visible = true;
					
					if (visibilityManager.useOldInterface)
					{
						this.hudGroup.zoomInButton.visible = true;
						this.hudGroup.zoomOutButton.visible = true;
						this.hudGroup.optionsButton.visible = true;
					}
					else
					{
						this.hudGroup.soundButton.visible = false;
						this.hudGroup.fullScreenButton.visible = false;
					}
					this.hudGroup.autonomousActionGroup.visible = true;
					
					//this.hudGroup.topBar.visible = true;
					this.hudGroup.megaUI.visible = true;
					
					//this.hudGroup.levelClock.visible = true;
					this.hudGroup.updatesGroup.visible = true; 
					//this.hudGroup.megaUI.setToMiniMap();
					
					if (this.useEndingButtons)
					{
						if (this.hudGroup.endingWindow.atleastOneEnding)
						{
							this.hudGroup.endingWindow.visible = true;
						}
					}
					
					
					if (this.possibleEndings.length > 0)
					{
						//hudGroup.goToEndingButton.visible = true;
					}
					
					if (visibilityManager.useOldInterface)
					{
						if (this.useJuicePoints)
						{
							this.hudGroup.juiceBar.visible = true;
						}
					}
					
					//start click-and-drag panning
					if(this.enableDragPanning)
						this.worldGroup.panningEnabled = true;
					
						
					//this.hudGroup.fadeIn.play([this.hudGroup.megaUI,this.hudGroup.juiceBar, this.hudGroup.topBar]);
						
					//Deal with character idle walkings
					
					for each (var avatar:Avatar in worldGroup.avatars) {
						//var avatar:Avatar = worldGroup.avatars[character.characterName.toLowerCase()];
						var zone:Zone = avatar.currentZone;
						var feetY:Number = avatar.locY + (avatar.clip.height / 2); // this is the actual y value I care about -- where their feet are.
						if (avatar.state == Avatar.STANDING) {
							//Debug.debug(this, "AT LEAST ONCE IT WAS STANDING");
							if (Math.random() < IDLE_MOVEMENT_FREQUENCY) {
								if(avatar.currentZone) // only do this if the avatar HAS a zone.
									avatar.findAndMoveAvatarToLocationWithinTheirZone();
							}
						}
						
					}
					
						
					if (this.currentLevel.endable)
					{
						this.dealWithDancingAnimations();
					}
					
					
					//Deal with the social status updates
					if(visibilityManager.useSSUs){ // Check to see if we actually want to show SSUs.
						for each (var char:Character in cif.cast.characters)
						{
							var isInLevel:Boolean = isCharInLevel(char);
							
							//this is the situation where we haven't seen a ssu yet
							if (this.timeOfLastSocialStatusUpdate[char.characterName] == null)
							{
								this.timeOfLastSocialStatusUpdate[char.characterName] = currentTime;
							}
							
							if (currentTime - this.timeOfLastSocialStatusUpdate[char.characterName] > this.timeTillNextSocialStatusUpdate[char.characterName])
							{
								if (isInLevel && this.worldGroup.avatars[char.characterName.toLowerCase()].state == Avatar.WALKING)
								{
									//if the character is walking wait five seconds.
									this.timeTillNextSocialStatusUpdate[char.characterName] += 5000;
								}
								else
								{	
									var notAlreadyPending:Boolean = true;
									for each (var pendingSSU:Object in this.pendingSSUs)
									{
										if (pendingSSU.char.characterName == char.characterName)
										{
											notAlreadyPending = false;
										}
									}
									if (notAlreadyPending)
									{
										var obj:Object = new Object();
										obj.char = char;
										obj.isInLevel = isInLevel;
										pendingSSUs.push(obj);
									}
								}
							}
						}
						
						
						
						//here we want to display the ssu if there is one to display
						var timeSinceLastSSU:Number = currentTime - timeOfLastSSU;
						if (timeSinceLastSSU > 4000)
						{
							if (pendingSSUs.length > 0)
							{
								var ssuText:String = this.getSocialStatusUpdate(pendingSSUs[0].char,pendingSSUs[0].isInLevel);
								if (ssuText != "")
								{
									//Debug.debug(this, "onEnterFrame() SSU for " + char.characterName + ": " + ssuText);
									//hudGroup.ssuVisualizer.addSSUEntry(char.characterName, ssuText);
									hudGroup.updatesGroup.createSSUPopUp(pendingSSUs[0].char.characterName, ssuText);
									//this.hudGroup.megaUI.updateNumUnreadSSU(this.hudGroup.megaUI.numUnread + 1);
								}
								this.timeOfLastSocialStatusUpdate[pendingSSUs[0].char.characterName] = currentTime;
								this.timeTillNextSocialStatusUpdate[pendingSSUs[0].char.characterName] = (pendingSSUs[0].isInLevel)?Utility.randRange(PromWeek.GameEngine.MIN_SSU_UPDATE_TIME_IN_LEVEL, GameEngine.MAX_SSU_UPDATE_TIME_IN_LEVEL):Utility.randRange(GameEngine.MIN_SSU_UPDATE_TIME_NOT_IN_LEVEL, GameEngine.MAX_SSU_UPDATE_TIME_NOT_IN_LEVEL)							
								
								timeOfLastSSU = currentTime;
								pendingSSUs.splice(0, 1);
							}
						}
					}
					
					if (this.currentStory.isQuickPlay)
					{
						//Find out if they've completed all goals for quick play purposes.
						checkQuickPlayGoalProgress();
						
						
						//Deal with the level objective text (likely to only show up in quick play mode
						//updateQuickPlayLevelInstructions();
						
						//handle whether or not any hints should show.
						visibilityManager.handleQuickPlayHintVisiblity(); // I think that this should go right in here! If we haven't completed all of the goals yet!
					}
					
					//this.hudGroup.topBar.visible = true;
					//this.hudGroup.megaUI.visible = true;
					//this.hudGroup.juiceBar.visible = true;
					//this.hudGroup.fadeIn.play([this.hudGroup.megaUI,this.hudGroup.juiceBar,this.hudGroup.topBar]);
					
					
					if (this.levelTimeRemaining <= 0)
					{
						if (currentStory.isQuickPlay) {
							// we want to do different things for if the level time runs out in quick play mode or not!
							// If it runs out of time and we've accomplished all tasks, then we are happy (and I think code in other places will deal with how to proceed)
							// if we run out of time and we haven't accomplished all tasks, then we are sad (and I think a little window will pop up asking the player what they want to do next)
							if (checkQuickPlayGoalProgress()) {
								//they solved the goals! Yay!
							}
							else {
								//They didn't solve the goals. They lost. :(
								hudGroup.handleQuickPlayFailedMenuScreen();								
							}
						}
						else{
							if (currentLevel.endable)
							{
								this.hudGroup.skipToEndOfNight();
								return;
							}
							else
							{
								this.currentState = "EndOfLevelResult";
								return;
							}
						}
					}
					else {
						//the game is still going... make sure that mouse clicks become enabled if they got disabled...
						if (worldGroup.mouseEnabled == false && !visibilityManager.quickPlayLevelGoalsCompleted) {
							hudGroup.inGameOptionMenu.enableGameplayClicks();
						}
					}
					
					if(this.enableSidePanning) {
						//trace(worldGroup.x);
						if (this.scrollWorldGroupLeft)
							//&& this.worldGroup.x + elapsedTime * worldGroupScrollSpeed < this.resourceLibrary.settings[scenarioDescription.settingName].imgWidth)
						{
							this.camera.setMode(PromWeek.Camera.MANUAL_MODE)
							this.camera.translate( -elapsedTime * this.worldGroupScrollSpeed);
							//this.camera.freeLookOffsetLeft += elapsedTime * this.worldGroupScrollSpeed;
						}
						if (this.scrollWorldGroupRight)
						{
							this.camera.setMode(PromWeek.Camera.MANUAL_MODE)
							this.camera.translate(elapsedTime * this.worldGroupScrollSpeed);
							//this.camera.freeLookOffsetLeft -= elapsedTime * this.worldGroupScrollSpeed;
						}
						if (this.scrollWorldGroupUp)
						{
							this.camera.setMode(PromWeek.Camera.MANUAL_MODE)
							this.camera.translate(0,-elapsedTime * this.worldGroupScrollSpeed);
							//this.camera.freeLookOffsetLeft -= elapsedTime * this.worldGroupScrollSpeed;						
						}
						if (this.scrollWorldGroupDown)
						{
							this.camera.setMode(PromWeek.Camera.MANUAL_MODE)
							this.camera.translate(0, elapsedTime * this.worldGroupScrollSpeed);
							//Debug.debug(this,"Should be moving down");
							//this.camera.freeLookOffsetLeft -= elapsedTime * this.worldGroupScrollSpeed;
						}
					}
					
					//Handle the nice gentle fade out of the level objective screen.
					if (gentleFadeFlag) {
						this.hudGroup.levelObjectiveScreen.alpha -= .03;
						if (this.hudGroup.levelObjectiveScreen.alpha <= 0) {
							gentleFadeFlag = false;
							//this.currentState = "Interaction";
							//this.hudGroup.removeElement(this.hudGroup.levelObjectiveScreen);
							this.hudGroup.levelObjectiveScreen.visible = false;
							this.hudGroup.levelObjectiveScreen.alpha = 1;
							if (this.currentLevel.isTutorial) {
								this.tutorialPopup.visible = true;
								
								if (this.tutorial.tutorialStepCounter == 0)
								{
									//zoom in on a character if appropriate on the first tutorial step
									this.tutorial.zoomToCharacter();
								}
								
								this.tutorial.positionPopUpWindow();
							}
							//trace("done fading!");
							//hudGroup.setFocus();						
						}
					}
				}
				if (!this.isFormingIntent && this.currentState != "LoadingLevel" )
				{
					if(worldGroup)
						worldGroup.update(elapsedTime);
					if (hudGroup)
						hudGroup.update(elapsedTime);
					if(camera)
						camera.framingAvatarsUpdate();
				}
				
				if (this.currentState == "Performance") 
				{
					ToolTipManager.enabled = false;
					
					this.hudGroup.zoomInButton.visible = false;
					this.hudGroup.zoomOutButton.visible = false;
					
					this.hudGroup.autonomousActionGroup.visible = false;
					
					for each (var a:Avatar in this.worldGroup.avatars) 
					{
						if (a.namePlate != null)
						{
							//a.removeElement(a.namePlate);
							//hudGroup.characterNameplateGroup.removeAllElements(); // I think this should actually destroy all of it!
							a.namePlate = null;
						}
					
						
						
						if (a.clip.hasEventListener(MouseEvent.MOUSE_DOWN)) 
						{
							a.clip.removeEventListener(MouseEvent.MOUSE_DOWN, a.onClick );
							a.clip.removeEventListener(MouseEvent.ROLL_OVER, a.onRollOver );
							a.clip.removeEventListener(MouseEvent.ROLL_OUT, a.onRollOut );
							//Debug.debug(this, "onEnterFrameEvent() removing a.onClick for " + a.characterName);
						}
					}
					hudGroup.characterNameplateGroup.removeAllElements();
					
					this.hudGroup.ssuVisualizer.visible = false;
					
					//Keep track of how long we've been in performance state, if it has been more than five seconds, make the click to continue text visible.
					var tempTime:Number = new Date().time
					//Debug.debug(this, "about to deal with the timer code that I just wrote: " + tempTime + " and the dialogue start time is: " + currentLineOfDialogueStartTime);
					//Make a little 'click to continue' reminder show up.
					if (tempTime - currentLineOfDialogueStartTime > 5000  && !hudGroup.otherIsApproachingText.visible) {
						//Debug.debug(this, "Oh my gosh!  I think that I should make the thing visible now!");
						hudGroup.clickToContinueText.visible = true;
					}
					
					//this.hudGroup.fadeOut.play([this.hudGroup.megaUI,this.hudGroup.juiceBar, this.hudGroup.topBar]);
				}
				else
				{
					ToolTipManager.enabled = true;
				}
				
				if (initiatorArrived && responderArrived)
				{
					if (this.currentState == "Performance") 
					{
						this.startOfSocialExchangePerformance = new Date().time;
						
						//this.hudGroup.topBar.visible = false;
						//this.hudGroup.megaUI.visible = false;
						if (this.useEndingButtons)
						{
							this.hudGroup.endingWindow.visible = false;
						}
						//this.hudGroup.goToEndingButton.visible = false;
						if (this.useJuicePoints)
						{
							this.hudGroup.juiceBar.visible = false
							this.hudGroup.topBar.visible = false
						}
						this.hudGroup.megaUI.visible = false;
						//this.hudGroup.megaUI.clear();
						
						responderArrived = false;
						initiatorArrived = false;
						otherArrived = false;
						
						//socialGamePlaying tells the first lineOfDialogue to display
						socialGamePlaying = true;
						socialGamePlaying = true;
						dialougeLineNumber = 0;
						
						currCharForIntent = 0;
						
						//stop playing change animations by removing all pending change animations
						if (this.hudGroup.toDisplayChangePreds.length > 0)
						{
							this.hudGroup.toDisplayChangePreds.splice(0, this.hudGroup.toDisplayChangePreds.length - 1)
						}
						if (this.hudGroup.toDisplaySubjectiveChangeAnimations.length > 0)
						{
							this.hudGroup.toDisplaySubjectiveChangeAnimations.splice(0, this.hudGroup.toDisplaySubjectiveChangeAnimations.length - 1)
						}
						
						hudGroup.megaUI.initiatorCharButton.visible = false;
						hudGroup.megaUI.responderCharButton.visible = false;
						hudGroup.megaUI.socialGameButtonGroup.visible = false;
						
						
						
						onClickInPerformanceState();
						//updatePerformance();
					}
				}
			}
		}

		
		public function resetSocialGameInfoWindowAndSelections():void
		{
			currentlySelectedSG = "";
			currentlySelectedInitiator = "";
			currentlySelectedResponder = "";
		}
		
		
		public function initializeAllSSUTimes():void
		{
			var char:Character;
			var isInLevel:Boolean;
			for each (char in cif.cast.characters)
			{
				isInLevel = isCharInLevel(char);
				this.timeTillNextSocialStatusUpdate[char.characterName] = (isInLevel)?Utility.randRange(PromWeek.GameEngine.MIN_SSU_UPDATE_TIME_IN_LEVEL, GameEngine.MAX_SSU_UPDATE_TIME_IN_LEVEL):Utility.randRange(GameEngine.MIN_SSU_UPDATE_TIME_NOT_IN_LEVEL, GameEngine.MAX_SSU_UPDATE_TIME_NOT_IN_LEVEL)
				this.timeOfLastSocialStatusUpdate[char.characterName] = new Date().time;
			}
		}
		
		public function isCharInLevel(char:Character):Boolean
		{
			for each (var char1:Character in this.currentLevel.cast)
			{
				if (char1.characterName == char.characterName)
				{
					return true;
				}
			}
			return false;
		}
		
		/**
		 * Finds the most salient SSU, and renders the text
		 * 
		 * @param	The char from whose perspective the SSU is from
		 * @return the completed string for the SSU ready to display
		 */
		public function getSocialStatusUpdate(char:Character, isInLevel:Boolean):String
		{
			var SSUs:Vector.<SocialStatusUpdateEntry> = (isInLevel)?cif.socialStatusUpdates:cif.socialStatusUpdatesNotInLevel;
			
			//These three vectors need to be in sync
			var possibleSSUs:Vector.<SocialStatusUpdateEntry> = new Vector.<SocialStatusUpdateEntry>();
			var possibleResponders:Vector.<Character> = new Vector.<Character>();
			var possibleOthers:Vector.<Character> = new Vector.<Character>();
			
			var responder:Character;
			var other:Character;
			
			var ssu:SocialStatusUpdateEntry;
			
			var goodEnoughSSU:SocialStatusUpdateEntry;
			var goodEnoughResponder:Character;
			var goodEnoughOther:Character;
			
			for each (ssu in SSUs)
			{
				if (!ssu.hasBeenSeen)
				{
					//if we have one of these that is good enough, don't both going through all of them
					if (goodEnoughSSU) break;
					
					if (!ssu.condition.requiresOnlyOneCharacter())
					{
						for each (responder in cif.cast.characters)
						{
							if (char.characterName != responder.characterName)
							{
								if (ssu.condition.requiresThirdCharacter())
								{
									//this means we should look through all possible others
									for each (other in cif.cast.characters)
									{
										if (char.characterName != other.characterName && other.characterName != responder.characterName)
										{
											//----------
											if (ssu.condition.evaluate(char, responder, other))
											{
												possibleSSUs.push(ssu);
												possibleResponders.push(responder);
												possibleOthers.push(other)
												
												ssu.scoreSalience();
												
												if (ssu.salienceScore >= GameEngine.SSU_THRESHOLD)
												{
													goodEnoughSSU = ssu;
													goodEnoughResponder = responder;
													goodEnoughOther = other;
												}
											}
										}
									}
								}
								else
								{
									//no other, means we don't need to loop through all the others
									//----------
									other = null;
									if (ssu.condition.evaluate(char, responder, other))
									{
										possibleSSUs.push(ssu);
										possibleResponders.push(responder);
										possibleOthers.push(null)
										
										ssu.scoreSalience();
										
										if (ssu.salienceScore >= GameEngine.SSU_THRESHOLD)
										{
											goodEnoughSSU = ssu;
											goodEnoughResponder = responder;
											goodEnoughOther = null;
										}
									}
									
								}
							}
						}
					}
					else
					{
						//this is when the condition rule doesn't refer to a respodner or other
						//we pass in a dummy character to make eval work nicely
						responder = cif.cast.characters[0];
						other = null;
						
						if (ssu.condition.evaluate(char, responder, other))
						{
							possibleSSUs.push(ssu);
							possibleResponders.push(null);
							possibleOthers.push(null)
							
							ssu.scoreSalience();
							
							if (ssu.salienceScore >= GameEngine.SSU_THRESHOLD)
							{
								goodEnoughSSU = ssu;
								goodEnoughResponder = null;
								goodEnoughOther = null;
							}
						}
					}
				}
			}
			
			var resultsString:String = "";
			
			var mostSalientSSU:SocialStatusUpdateEntry;
			var mostSalientResponder:Character;
			var mostSalientOther:Character;
			
			
			//goodEnoughSSU = null;
			if (goodEnoughSSU)
			{
				//if we were lucky enough to find a good enough ssu, use it instead of going through a set of possibleSSUs
				mostSalientSSU = goodEnoughSSU;
				mostSalientResponder = goodEnoughResponder;
				mostSalientOther = goodEnoughOther;
			}
			else
			{
				if (possibleSSUs.length > 0)
				{
					//go through all possible ssus (note how none of them were "good enough") and find the most awesome one
					var highestSalienceScore:Number = -10000;
					var tmpSalience:Number;

					for (var i:int = 0; i < possibleSSUs.length; i++ )
					{
						tmpSalience = possibleSSUs[i].salienceScore;
						if (tmpSalience > highestSalienceScore)
						{
							highestSalienceScore = tmpSalience;
							mostSalientSSU = possibleSSUs[i];
							mostSalientResponder = possibleResponders[i];
							mostSalientOther = possibleOthers[i];
						}
					}
				}
			}
			

			//if they really didn't have anything *that* awesome to say, just don't say anything about half the time
			if (mostSalientSSU)
			{
				//Debug.debug(this,"SalienceScore: " + mostSalientSSU.salienceScore);
				if (mostSalientSSU.salienceScore < PromWeek.GameEngine.SSU_THRESHOLD / 2)
				{
					if (Math.random() < 0.5)
					{
						mostSalientSSU = null;
					}
				}
			}
			//if we have found a salient ssu, make the string!
			if (mostSalientSSU)
			{
				for each (var loc:Locution in mostSalientSSU.locutions)
				{
					if (loc.getType() == "MixInLocution") {
						char.isSpeakerForMixInLocution = true;
						resultsString += loc.renderText(char, mostSalientResponder, mostSalientOther, null);
						char.isSpeakerForMixInLocution = false;
					}
					else {
						resultsString += loc.renderText(char,mostSalientResponder,mostSalientOther, null);
					}
					
				}
				mostSalientSSU.lastSeenTime = cif.time;
				mostSalientSSU.hasBeenSeen = true;
				if (isInLevel)
				{
					this.worldGroup.avatars[char.characterName.toLowerCase()].clip.gotoAndPlay("texting");
				}
			
			}
			
			return resultsString;
		}

		public function dealWithDancingAnimations():void
		{
			var avatar:Avatar;
			var currentTime:Number = new Date().time;
			
			for each (avatar in this.worldGroup.avatars )
			{
				if ((currentTime - avatar.lastTimeDanced) > avatar.timeTillNextDance)
				{
					if (avatar.state == Avatar.WALKING)
					{
						//if the character is walking wait five seconds.
						avatar.timeTillNextDance += 5000;
					}
					else
					{
						avatar.lastTimeDanced = currentTime;
						
						if (Math.random() > 0.4)
						{
							avatar.gotoAndPlay("dance_cool");
						}
						else
						{
							avatar.gotoAndPlay("dance_lame");
						}
						
						avatar.timeTillNextDance = Util.randRange(MIN_DANCE, MAX_DANCE);
					}
				}
			}
		}
		
		
		
		/**
		 * This function handles recognizing when autonomous actions should happen, updating them, removing them when no longer
		 * warranted, and scheduling them. 
		 */
		public function dealWithAutonomousActions():void
		{
			var aa:AutonomousAction;
			var i:int;
			var avatar:Avatar;
			var initiator:Character;
			var responder:Character;
			var gameScore:GameScore;
			var gameScores:Vector.<GameScore>;
			//update all intensityScores
			//for (i = 0 ; i < this.worldGroup.avatars.length; i++ )
			for each (avatar in this.worldGroup.avatars )
			{
				//avatar = this.worldGroup.avatars[i];
				aa = avatar.pendingAutonomousAction;
				
				if (aa)
				{
					//get the gamescore for the initiator
					initiator = cif.cast.getCharByName(aa.initiator);
					responder = cif.cast.getCharByName(aa.responder)
					
					gameScore = initiator.prospectiveMemory.getGameScoreByGameName(aa.gameName,responder);
					
					//update aa
					aa.intensityScore = gameScore.score;
					aa.remainingTimeUntilAction = aa.remainingTimeUntilAction - 1;
				}
			}
			
			//remove aa's if they are too low a desire now
			//for (i = 0 ; i < this.worldGroup.avatars.length; i++)
			for each (avatar in this.worldGroup.avatars)
			{
				//avatar = this.worldGroup.avatars[i];
				
				if (avatar.pendingAutonomousAction)
				{
					if (avatar.pendingAutonomousAction.intensityScore < avatar.pendingAutonomousAction.necessaryScore)
					{
						//this.hudGroup.updatesGroup.createAutonomousPopUp(avatar.pendingAutonomousAction,true);
						
						//Debug.debug(this,"dealWithAutonomousActions() " + aa.initiator + " no longer REALLY wants to play " + aa.gameName + " with " + aa.responder);
						avatar.pendingAutonomousAction = null
						
						// nuke the autonomousIcon for this guy
						delete hudGroup.autonomousIcons[avatar.characterName.toLowerCase()];// = null
						
					}
				}
			}
			
			// UPDATE THE AutonomousActionObjects!
			for each (var aan:AutonomousActionNotifier in hudGroup.autonomousIcons) {
				// gotta do some gnarly Czech here for preconditions:
				if(aan){
					aan.updateTime(-1)
					aan.notify()
					if(levelTime >= 1) {
						hudGroup.updatesGroup.createAutonomousPopUp(aan)
					}
				}
			}
			
			
			//check to see if we need to add any autonomous actions
			for each (initiator in this.currentLevel.cast)
			{
				for each (responder in this.currentLevel.cast)
				{
					if (initiator.characterName != responder.characterName)
					{
						gameScores = initiator.prospectiveMemory.getHighestGameScoresTo(responder.characterName, 1, AutonomousAction.DEFAULT_NECESSARY_SCORE)
						for each (gameScore in gameScores)
						{
							if (isValidAutonomousActionGame(gameScore.name))
							{
								if (this.worldGroup.avatars[initiator.characterName.toLowerCase()].pendingAutonomousAction)
								{
									if (this.worldGroup.avatars[initiator.characterName.toLowerCase()].pendingAutonomousAction.intensityScore < gameScore.score)
									{	
										if (!(this.worldGroup.avatars[initiator.characterName.toLowerCase()].pendingAutonomousAction.gameName == gameScore.name
												&& this.worldGroup.avatars[initiator.characterName.toLowerCase()].pendingAutonomousAction.initiator == gameScore.initiator
												&& this.worldGroup.avatars[initiator.characterName.toLowerCase()].pendingAutonomousAction.responder == gameScore.responder))
										{
											addAAN(aa,initiator,responder,gameScore)
										}
									}
								}
								else
								{
									addAAN(aa,initiator,responder,gameScore)
								}
							}
						}
					}
				}
			}
			
			
			//now that we have updated, removed and added autonomous actions, we can deal with scheduling them.
			//go through all that could be played, and then randomly choose one
			var possibleAutonomousActions:Vector.<AutonomousAction> = new Vector.<AutonomousAction>();
			for each (avatar in  this.worldGroup.avatars)
			{
				aa = avatar.pendingAutonomousAction;
				
				if (aa)
				{
					if (aa.remainingTimeUntilAction <= 0)
					{
						//this means it is time to roll!
						possibleAutonomousActions.push(aa);
					}
				}
			}
			//randomly choose the one to play
			if (possibleAutonomousActions.length > 0)
			{
				aa = possibleAutonomousActions[Util.randRange(0, possibleAutonomousActions.length - 1)];			
				this.socialGameToPerform = aa.gameName;
				
				this.initiatorName = aa.initiator.toLowerCase();
				this.responderName = aa.responder.toLowerCase();
				
				this.worldGroup.avatars[this.initiatorName].lookingAtTarget = this.responderName;
				this.worldGroup.avatars[this.responderName].lookingAtTarget = this.initiatorName;

				this.socialGameToPerform = aa.gameName;
				
				//clear out this autonomous action
				this.worldGroup.avatars[aa.initiator.toLowerCase()].pendingAutonomousAction = null;
				
				Debug.debug(this, "WE SHOULD TOTALLY BE PLAYING " + aa.gameName + " RIGHT NOW!");
				
				this.currentState = "Performance";
			}
		}
		
		
		
		public function isValidAutonomousActionGame(gameN:String):Boolean
		{
			var socialG:SocialGame = cif.socialGamesLib.getByName(gameN); 
			var intentPred:int = socialG.intents[0].predicates[0].getIntentType();
			if (intentPred == Predicate.INTENT_FRIENDS || intentPred == Predicate.INTENT_END_FRIENDS
				|| intentPred == Predicate.INTENT_DATING || intentPred == Predicate.INTENT_END_DATING
				|| intentPred == Predicate.INTENT_ENEMIES || intentPred == Predicate.INTENT_END_ENEMIES)
			{
				return true
			}
			else
			{
				return false;
			}
		}
		
		
		/**
		 * this is to get rid of duplicate code
		 */
		private function addAAN(aa:AutonomousAction,initiator:Character, responder:Character, gameScore:GameScore):void {
			if (hudGroup.NUMBER_OF_AANS <= MAXIMUM_AUTONOMOUS_NOTIFICATIONS - 1) {
				// if it's not a relationship and we have that bool on, F OFF!
				if (AUTONOMOUS_RELATIONSHIP_ONLY && isNetwork(gameScore)) {
					return
				}
				//this means they didn't already want to really do something and they really want to do something now
				aa = new AutonomousAction();
				aa.gameName = gameScore.name;
				aa.intensityScore = gameScore.score;
				aa.initiator = initiator.characterName;
				aa.responder = responder.characterName;
				this.worldGroup.avatars[initiator.characterName.toLowerCase()].pendingAutonomousAction = aa;
				// do some fancy pants
				if(levelTime >= 1) {
					hudGroup.updatesGroup.createAutonomousPopUp(hudGroup.addAutonomousActionNotifier(aa));
				}
				Debug.debug(this, aa.initiator + " really wants to play " + aa.gameName + " with " + responder.characterName + ": " + aa.intensityScore);
			}
			
		}
		
		private function isNetwork(gameScore:GameScore):Boolean {
			var intentType:Number = cif.socialGamesLib.getByName(gameScore.name).intents[0].predicates[0].getIntentType()
			return intentType == Predicate.INTENT_BUDDY_UP || 
				   intentType == Predicate.INTENT_BUDDY_DOWN || 
				   intentType == Predicate.INTENT_COOL_UP || 
				   intentType == Predicate.INTENT_COOL_DOWN || 
				   intentType == Predicate.INTENT_ROMANCE_UP || 
				   intentType == Predicate.INTENT_ROMANCE_DOWN
	    }
		
		public function set levelTimeRemaining(t:Number):void {
			this.levelTime = t;
			this.hudGroup.megaUI.levelClock.setTimeRemaining(t);
			if(!this.currentLevel.isSandbox){ // due to the nature of logic, only update this variable in non-sandbox level.
				this.hudGroup.topBar.numTurnsLeftButton.turnsLeft = t;
			}
			this.hudGroup.topBar.numTurnsLeftButton.skin.invalidateDisplayList();
			//this.hudGroup.topBar.setTimeThingy(t);
			// for the timeclock
			//this.hudGroup.promTimeClock.setTimeRemaining(t)
		}
		
		public function get levelTimeRemaining():Number {
			return this.levelTime;
		}
		
		public function setDimensions(w:Number, h:Number, s:Number = 1.0):void
		{
			Debug.debug(this, "setDimensions() width: " + w + " height: " + h + " scale: " + s);
			Utility.log(this, "setDimensions() width: " + w + " height: " + h + " scale: " + s);
			
			this.APPLICATION_HEIGHT = h;
			this.APPLICATION_WIDTH = w;
			this.APPLICATION_SCALE = s;
			
			this.hudGroup.appWidth = w;
			this.hudGroup.appHeight = h;
			
			this.width = w;
			this.height = h;
			
			//this.hudGroup.setDimensions(w, h);
			this.hudGroup.setScale(s);
			
			if (this.camera) {
				this.camera.setWindowDimensions(this.APPLICATION_HEIGHT, this.APPLICATION_WIDTH);
				//this.camera.setWorldDimensions(h, w);
			}
			
			
			
			this.hudGroup.mainMenuScreen.width = w;
			this.hudGroup.mainMenuScreen.height = h;
			this.hudGroup.storySelectionScreen.width = w;
			this.hudGroup.storySelectionScreen.height = h;
			this.hudGroup.sandboxMenuScreen.width = w;
			this.hudGroup.sandboxMenuScreen.height = h;
			this.hudGroup.levelResultsScreen.width = w;
			this.hudGroup.levelResultsScreen.height = h;
			this.hudGroup.creditsScreen.width = w;
			this.hudGroup.creditsScreen.height = h;
			this.hudGroup.endOfStoryScreen.width = w;
			this.hudGroup.endOfStoryScreen.height = h;
			this.hudGroup.goalProgressGroup.width = w;
			this.hudGroup.goalProgressGroup.height = h;
			this.hudGroup.postSGSFDBEntry.width = w;
			this.hudGroup.postSGSFDBEntry.height = h;
			this.hudGroup.quickPlayInstructionsText.width = w;
			this.hudGroup.quickPlayInstructionsText.height = h;
			this.hudGroup.quickPlayHintGroup.width = w;
			this.hudGroup.quickPlayHintGroup.height = h;
			this.hudGroup.endingTitleScreen.width = w;
			this.hudGroup.endingTitleScreen.height = h;
			
			this.tutorial.positionPopUpWindow();
			
			this.hudGroup.updatesGroup.x = this.APPLICATION_WIDTH;
			this.hudGroup.ssuVisualizer.x = this.APPLICATION_WIDTH - this.hudGroup.ssuVisualizer.width;
			this.hudGroup.charactersAreThinkingGroup.x = this.APPLICATION_WIDTH - this.hudGroup.charactersAreThinkingGroup.width - 10;
			this.hudGroup.mainMenuScreen.background.x =  this.APPLICATION_WIDTH / 2 - this.hudGroup.mainMenuScreen.background.contentWidth / 2;
			//@@@ this is where we will reposition things when we make it big
			if (!VisibilityManager.getInstance().useOldInterface)
			{
				this.hudGroup.optionsDropDownPanel.x = this.APPLICATION_WIDTH - this.hudGroup.optionsDropDownPanel.width;
				
				if (this.socialGamePlaying && this.primaryAvatarSelection != null && this.secondaryAvatarSelection != null)
				{
					var performers:Dictionary = new Dictionary();
					performers[this.primaryAvatarSelection.toLowerCase()] = this.worldGroup.avatars[this.socialGameContext.initiator.toLowerCase()];
					performers[this.secondaryAvatarSelection.toLowerCase()] = this.worldGroup.avatars[this.socialGameContext.responder.toLowerCase()];
					if (this.socialGameContext.other != "")
					{
						performers[this.socialGameContext.other.toLowerCase()] = this.worldGroup.avatars[this.socialGameContext.other.toLowerCase()];
					}
					this.camera.centerOnCharacters(performers);
				}
				else
				{
					if (this.secondaryAvatarSelection != null)
					{
						var avatarToZoomOn:Avatar;
						for each (var avatar:Avatar in this.worldGroup.avatars)
						{
							if (avatar.characterName.toLowerCase() == this.secondaryAvatarSelection.toLowerCase())
							{
								avatarToZoomOn = avatar;
							}
						}
						if (avatarToZoomOn != null)
						{
							this.camera.absolutePositionCenter(avatarToZoomOn.locX, avatarToZoomOn.locY, 1.5);
						}
					}	
					else
					{
						if (this.camera != null)
						{
							this.camera.centerOnAllCharacters();
						}
					}
				}
			}
			
			this.hudGroup.topBar.juiceBar.updateOnResize(jpm.currentJuicePoints);
			
			
			this.invalidateProperties()
			this.invalidateSize()
			this.invalidateDisplayList()	
		}
		
		/**
		 * Translates XML story specifications into instances of the Story class.
		 * @param	storiesXML	Stories as XML.
		 */
		public function loadStories(storiesXML:XML):void {
			var story:Story;
			if (!this.stories)
				this.stories = new Vector.<Story>();
			for each (var storyXML:XML in storiesXML..Story) {
				story = new Story();
				story.loadFromXML(storyXML);
				this.stories.push(story);
			}
		}
		
		/**
		 * Loads up the achievements into the vector. Currently there is no xml or anything so it just adds a few dummy achievements.
		 * @param	
		 */
		public function loadAchievements():void {
			var achieve1:Achievement;
			var achieve2:Achievement;
			var achieve3:Achievement;
			var achieve4:Achievement;
			this.achievements = new Vector.<Achievement>();
			
			achieve1 = new Achievement();
			achieve1.picture = resourceLibrary.portraits['monica'];
			achieve1.grayedPicture = resourceLibrary.portraits['noOne'];
			achieve1.locX = 100;
			achieve1.locY = 100;
			achieve1.complete = true;
			achieve1.name = "I Kissed a Girl and I Liked It";
			achieve1.toolTip = "Get two girls to date";
			this.achievements.push(achieve1);
			
			achieve2 = new Achievement();
			achieve2.picture = resourceLibrary.portraits['gunter'];
			achieve2.grayedPicture = resourceLibrary.portraits['noOne'];
			achieve2.locX = 230;
			achieve2.locY = 130;
			achieve2.needsToFadeIn = true;
			achieve2.complete = true;
			achieve2.name = "Bromance";
			achieve2.toolTip = "Get two boys to date";
			this.achievements.push(achieve2);
			
			achieve3 = new Achievement();
			achieve3.picture = resourceLibrary.statusIcons['feels out of place'];
			achieve3.grayedPicture = resourceLibrary.portraits['noOne'];
			achieve3.locX = 70;
			achieve3.locY = 400;
			achieve3.name = "Do A Barrel Roll";
			achieve3.toolTip = "Have one character 'Give Advice' to all other characters";
			this.achievements.push(achieve3);
			
			achieve4 = new Achievement();
			achieve4.picture = resourceLibrary.statusIcons['heartbroken'];
			achieve4.grayedPicture = resourceLibrary.portraits['noOne'];
			achieve4.locX = 300;
			achieve4.locY = 400;
			achieve4.needsToFadeIn = true;
			achieve4.complete = true;
			achieve4.name = "You're Tearing Me Apart";
			achieve4.toolTip = "Get a girl to cheat on her trusting boyfriend.";
			this.achievements.push(achieve4);
			
			
			responsePhrases = new Dictionary();
			for (var intentID:int = 0; intentID < 12; intentID++)
			{
				var intentName:String = Predicate.getIntentNameByNumber(intentID);
				var indexString:String = intentName + "-accept-weak";
				var responses:Vector.<String> = new Vector.<String>();
				responsePhrases[indexString] = responses;
				
				indexString = intentName + "-accept-medium";
				responses = new Vector.<String>();
				responsePhrases[indexString] = responses;
				
				indexString = intentName + "-accept-strong";
				responses = new Vector.<String>();
				responsePhrases[indexString] = responses;
				
				indexString = intentName + "-reject-weak";
				responses = new Vector.<String>();
				responsePhrases[indexString] = responses;
				
				indexString = intentName + "-reject-medium";
				responses = new Vector.<String>();
				responsePhrases[indexString] = responses;
				
				indexString = intentName + "-reject-strong";
				responses = new Vector.<String>();
				responsePhrases[indexString] = responses;
			}
			
			
			//The format, as you can see in the below example is {intent}-{accept/reject}-{weak/medium/strong}
			//Check out the example for intent(friends) below.
			
			//Here are the rest of the intent parts of the index string:
			//"intent(friends)" (started below)
			//"intent(end_friends)"
			//"intent(dating)"
			//"intent(end_dating)"
			//"intent(enemies)"
			//"intent(end_enemies)"
			//"intent(buddy_up)"
			//"intent(buddy_down)"
			//"intent(romance_up)"
			//"intent(romance_down)"
			//"intent(cool_up)"
			//"intent(cool_down)"
			
			//responsePhrases["intent(friends)-accept-weak"].push("Uh... sure.");
			//responsePhrases["intent(friends)-accept-weak"].push("Well, OK");
			//responsePhrases["intent(friends)-accept-weak"].push("I guess");//You can add as many as you want
			//responsePhrases["intent(friends)-accept-medium"].push("Sounds good");
			//responsePhrases["intent(friends)-accept-strong"].push("Totally!");
			//responsePhrases["intent(friends)-reject-weak"].push("I'll pass");
			//responsePhrases["intent(friends)-reject-medium"].push("No way");
			//responsePhrases["intent(friends)-reject-strong"].push("I'd rather choke on a cheezetoo"); //I think we have a good amount of room for these ones. I wouldn't get any longer than this though...
			responsePhrases["intent(friends)-reject-strong"].push("No freaking way!");
			responsePhrases["intent(friends)-reject-medium"].push("I don't think so.");
			responsePhrases["intent(friends)-reject-weak"].push("Nah.");
			responsePhrases["intent(friends)-accept-weak"].push("I suppose.");
			responsePhrases["intent(friends)-accept-medium"].push("Sure!");
			responsePhrases["intent(friends)-accept-strong"].push("Yeah totally!");

			responsePhrases["intent(end_friends)-reject-strong"].push("What?! We're BFFs!");
			responsePhrases["intent(end_friends)-reject-medium"].push("No way!");
			responsePhrases["intent(end_friends)-reject-weak"].push("Nah, things are good.");
			responsePhrases["intent(end_friends)-accept-weak"].push("Bye, then.");
			responsePhrases["intent(end_friends)-accept-medium"].push("Finally.");
			responsePhrases["intent(end_friends)-accept-strong"].push("Get out of my life!");

			responsePhrases["intent(dating)-reject-strong"].push("Not in a million years.");
			responsePhrases["intent(dating)-reject-medium"].push("You're not my type.");
			responsePhrases["intent(dating)-reject-weak"].push("I don't think so.");
			responsePhrases["intent(dating)-accept-weak"].push("You'll do.");
			responsePhrases["intent(dating)-accept-medium"].push("Wow, totally!");
			responsePhrases["intent(dating)-accept-strong"].push("I'm yours forever.");

			responsePhrases["intent(end_dating)-reject-strong"].push("You're mine forever.");
			responsePhrases["intent(end_dating)-reject-medium"].push("No way, sweetie!");
			responsePhrases["intent(end_dating)-reject-weak"].push("We're good together!");
			responsePhrases["intent(end_dating)-accept-weak"].push("I suppose it's over.");
			responsePhrases["intent(end_dating)-accept-medium"].push("Yeah, we're over.");
			responsePhrases["intent(end_dating)-accept-strong"].push("This is so totally over.");

			responsePhrases["intent(enemies)-reject-strong"].push("I could never hate you!");
			responsePhrases["intent(enemies)-reject-medium"].push("Why the hate?");
			responsePhrases["intent(enemies)-reject-weak"].push("Rather not.");
			responsePhrases["intent(enemies)-accept-weak"].push("If we must.");
			responsePhrases["intent(enemies)-accept-medium"].push("Bring it on.");
			responsePhrases["intent(enemies)-accept-strong"].push("I hate you so much.");

			responsePhrases["intent(end_enemies)-reject-strong"].push("Die in a fire.");
			responsePhrases["intent(end_enemies)-reject-medium"].push("Yeah, right.");
			responsePhrases["intent(end_enemies)-reject-weak"].push("Nah.");
			responsePhrases["intent(end_enemies)-accept-weak"].push("Yeah, I'm done.");
			responsePhrases["intent(end_enemies)-accept-medium"].push("Let's bury the hatchet.");
			responsePhrases["intent(end_enemies)-accept-strong"].push("Peace at last!!");

			responsePhrases["intent(buddy_up)-reject-strong"].push("Don't make me laugh.");
			responsePhrases["intent(buddy_up)-reject-medium"].push("Not gonna happen.");
			responsePhrases["intent(buddy_up)-reject-weak"].push("I'm kinda busy.");
			responsePhrases["intent(buddy_up)-accept-weak"].push("We can hang, I guess.");
			responsePhrases["intent(buddy_up)-accept-medium"].push("Sounds great!");
			responsePhrases["intent(buddy_up)-accept-strong"].push("AWESOME!");

			responsePhrases["intent(buddy_down)-reject-strong"].push("You could never let me down!");
			responsePhrases["intent(buddy_down)-reject-medium"].push("No, we're too tight!");
			responsePhrases["intent(buddy_down)-reject-weak"].push("Nah.");
			responsePhrases["intent(buddy_down)-accept-weak"].push("Well, okay.");
			responsePhrases["intent(buddy_down)-accept-medium"].push("Yeah, forget you.");
			responsePhrases["intent(buddy_down)-accept-strong"].push("I totally hate you.");

			responsePhrases["intent(romance_up)-reject-strong"].push("Totally gross!");
			responsePhrases["intent(romance_up)-reject-medium"].push("Not interested.");
			responsePhrases["intent(romance_up)-reject-weak"].push("Not really my type.");
			responsePhrases["intent(romance_up)-accept-weak"].push("That's cute, I guess.");
			responsePhrases["intent(romance_up)-accept-medium"].push("How romantic.");
			responsePhrases["intent(romance_up)-accept-strong"].push("Be still my heart!");

			responsePhrases["intent(romance_down)-reject-strong"].push("No!! You're adorable!");
			responsePhrases["intent(romance_down)-reject-medium"].push("No, I'm into you!");
			responsePhrases["intent(romance_down)-reject-weak"].push("Not quite enough.");
			responsePhrases["intent(romance_down)-accept-weak"].push("OK, you've got flaws.");
			responsePhrases["intent(romance_down)-accept-medium"].push("Yeah, what a turn-off.");
			responsePhrases["intent(romance_down)-accept-strong"].push("Totally grossed-out.");

			responsePhrases["intent(cool_up)-reject-strong"].push("Totally uncool.");
			responsePhrases["intent(cool_up)-reject-medium"].push("Not cool at all.");
			responsePhrases["intent(cool_up)-reject-weak"].push("Not that cool.");
			responsePhrases["intent(cool_up)-accept-weak"].push("That's cool, I suppose.");
			responsePhrases["intent(cool_up)-accept-medium"].push("Pretty cool!");
			responsePhrases["intent(cool_up)-accept-strong"].push("So cool!!");

			responsePhrases["intent(cool_down)-reject-strong"].push("No way! You're the coolest!!");
			responsePhrases["intent(cool_down)-reject-medium"].push("No, you're totally cool!");
			responsePhrases["intent(cool_down)-reject-weak"].push("No, you're kinda cool");
			responsePhrases["intent(cool_down)-accept-weak"].push("Sure, that's uncool.");
			responsePhrases["intent(cool_down)-accept-medium"].push("Yup, uncool");
			responsePhrases["intent(cool_down)-accept-strong"].push("Yup, so uncool.");
		}
		
		
		
		
		/**
		 * Makes a level the actively simulated level.
		 * @param	level
		 */
		public function activateLevel(levelIndex:Number):void {
			//load setting
			//this.finishedLoading = false;
			Debug.debug(this, "activateLevel() levelIndex = " + levelIndex);
			this.hudGroup.megaUI.clear();
			this.hudGroup.megaUI.onMinimizeButtonClicked();
			
			this.pendingSSUs = new Vector.<Object>();
			
			//remove old UI elements
			if(this.worldGroup) {
				this.removeElement(this.worldGroup);
				this.worldGroup.cleanUp()
			}
			//this.removeElement(this.hudGroup);
			
			if (MINI_MAP)
			{
				if (this.miniMap) {
					this.removeElement(this.miniMap);
					
				}
			}
			
			
			if (levelIndex != 0)
			{
				this.hudGroup.megaUI.goalButtonHasBeenClicked = true;
				this.hudGroup.megaUI.unglowGoalButton.play();
			}
			
			//get new UI elements
			this.worldGroup = new PromWeek.WorldGroup();
			//this.worldGroup.worldGroupInitialize();
			//this.hudGroup = new PromWeek.HUDGroup();
			if (MINI_MAP)
			{
				this.miniMap = new PromWeek.MiniMap();
			
				//<prom:MiniMap id="miniMap" scaleX="0.1" scaleY="0.1" x="200" y="200"/>
				
				this.addElement(this.miniMap);
				this.miniMap.scaleX = 0.1;
				this.miniMap.scaleY = 0.1;
				this.miniMap.x = 50;
				this.miniMap.y = 50;
				//add new UI elements
			}
			
			this.addElementAt(this.worldGroup,0);
			
			this.currentLevelIndex = levelIndex;
			
			this.worldGroup.loadLevel(this.currentStory.levels[levelIndex]);
			this.currentLevel = this.currentStory.levels[levelIndex];
			
			
			
			
			//Checks to see if this level is a tutorial level!  If so, it dispatches
			//the appropriate tutorial event!
			if (this.currentLevel.isTutorial) {
				Debug.debug(this, "activateLevel() about to dispatch an event!");
				dispatchEvent(new Event("startTutorial"));
				Debug.debug(this, "activateLevel() OK, the tutorial should be started now, I think!");
			}
			
			
			if (this.currentLevel.title == "Free Play!")
			{
				this.tutorialStopped = true;
				this.levelTimeRemaining = this.currentLevel.timeLimit;
				this.hudGroup.topBar.numTurnsLeftButton.update(-1,"Free Play",true);
				//this.levelTimeRemaining = this.currentLevel.timeLimit;
				//this.hudGroup.topBar.numTurnsLeftButton.dayOfWeek = "Free Play";
				this.hudGroup.topBar.numTurnsLeftButton.skin.invalidateDisplayList();
				this.hudGroup.megaUI.levelClock.setTimeRemaining(this.levelTimeRemaining);
			}
			else
			{
				if (!this.currentStory.isQuickPlay)
				{
					this.hudGroup.topBar.numTurnsLeftButton.visible = true;
				}
				this.levelTimeRemaining = this.currentLevel.timeLimit;
				this.hudGroup.topBar.numTurnsLeftButton.update(this.currentLevel.timeLimit,LevelResultsScreen.parseDay(this.currentLevel.title),false);
				this.hudGroup.topBar.numTurnsLeftButton.skin.invalidateDisplayList();
				this.hudGroup.megaUI.levelClock.setTimeRemaining(this.levelTimeRemaining);
			}
			
			if (!visibilityManager.useOldInterface)
			{
				this.hudGroup.initSelectGroup.populateFromCast(this.currentLevel.cast, 55);
				this.hudGroup.selectInitiatorGroup.visible = true;
				this.hudGroup.initiatorSelectedComponent.initSelectGroup.populateFromCast(this.currentLevel.cast, 40);
				this.hudGroup.initiatorSelectedComponent.respSelectGroup.chars = this.currentLevel.cast;
			}
						
			if (this.currentLevel.isSandbox)
			{
				this.hudGroup.megaUI.levelClock.visible = false;
				this.hudGroup.megaUI.levelClockButton.alpha = 0.3;
				this.hudGroup.megaUI.levelClockButton.enabled = false;
				this.hudGroup.megaUI.goalButton.enabled = false;
				this.hudGroup.megaUI.goalButton.alpha = 0.5;
			}
			else
			{
				this.hudGroup.megaUI.levelClock.visible = true;
				this.hudGroup.megaUI.goalButton.enabled = true;
				this.hudGroup.megaUI.levelClockButton.alpha = 1;
				this.hudGroup.megaUI.levelClockButton.enabled = true;
				this.hudGroup.megaUI.goalButton.alpha = 1;
			}
			
			var now:Number = new Date().time;
			for each (var avtr:Avatar in this.worldGroup.avatars )
			{
				this.timeOfLastSocialStatusUpdate[avtr.characterName] = now;
				avtr.namePlate = null;
				if (this.currentLevel.endable)
				{
					avtr.lastTimeDanced = now;
					avtr.timeTillNextDance = Util.randRange(MIN_DANCE, MAX_DANCE);
				}
			}
			this.hudGroup.characterNameplateGroup.removeAllElements();
			
			//for each (var end:Ending in currentStory.endings)
			//{
				//Debug.debug(this,"ENDING: " + end.toXMLString());
			//}
			
			this.initializeGameEngine();
			
			this.initializeCamera();
			
			//the new level is fully active -- return to interaction state.
			this.currentState = "LevelObjective";
			//this.finishedLoading = true;
			
			// increase playcount for this player
			this.getBackend().newLevel();
			
			
			//this will make sure the story goal windwo is in tip top shape.
			hudGroup.newStoryGoalWindow.visible = false;
			hudGroup.newStoryGoalWindow.closeButton.visible = true;
			hudGroup.newStoryGoalWindow.bgShape.visible = true;
			hudGroup.newStoryGoalWindow.goalTitleGroup.visible = true;
			
			
			
			for each (var character:Character in this.currentLevel.cast)
			{
				this.worldGroup.avatars[character.characterName.toLowerCase()].clip.alpha = 1;
				this.worldGroup.avatars[character.characterName.toLowerCase()].alpha = 1;
			}
			this.worldGroup.arrangeZOrders();
			this.camera.centerOnAllCharacters();
		}
		
		/**
		 * Set the parameters of the camera according to the current setting.
		 */
		public function initializeCamera():void {
			//this.camera.freeLook();
			//this.camera.translate(100);
			this.camera.zoom = performanceZoom;
			this.camera.setWindowDimensions(this.hudGroup.height, this.hudGroup.width);
			this.camera.setWorldDimensions(this.worldGroup.currentSetting.viewableHeight, this.worldGroup.currentSetting.viewableWidth);
			//this.camera.freeLook();
			if (!this.currentLevel.useDefinedCameraPosition) {
				Debug.debug(this, "initializeCamera() setting camera to NOT authored starting coordinates.");
				//@@@
				//this.camera.centerTheCamera(this.currentLevel.startZoom);
				this.camera.centerOnAllCharacters();
				
			}
			else {
				Debug.debug(this, "initializeCamera() setting camera to authored starting coordinates: " + this.currentLevel.cameraX + ", " + this.currentLevel.cameraY);
				this.camera.absolutePosition(this.currentLevel.cameraX, this.currentLevel.cameraY, this.currentLevel.startZoom);
			}			
		}
		/**
		 * 
		What is in the Interaction state?
		- CharInfoUI
		- Networks, relationships
		- social game button rings
		- selection circles
		- interaction mouse event handler
		- camera to show entire world
		What to do for the Performance state?
		- all UI elements from the Interaction state
		- add dialog bubbles (manage visibility as part of performance).
		- performance mouse event handler
		- camera to follow social game performers
		What to do for the Performance state?
		- Results UI
		- hide dialog bubbles
		- results mouse event handler
		- camera to follow social game performers
		-->
		 * @param	event
		 */
		public function onCurrentStateChange(event:StateChangeEvent):void {
			var a:Avatar; //avatar iterator
			var i:int;
			var castLength:Number;
			
			Debug.debug(this, "onCurrentStateChange() event.oldState: " + event.oldState + " event.newState: " + event.newState);
			
			this.setMusicByStateChange(event)
			
			if (event.newState != "Interaction" && event.newState != "Performance")
			{
				this.hudGroup.soundButton.visible = true;
				this.hudGroup.fullScreenButton.visible = true;
			}
			else
			{
				this.hudGroup.soundButton.visible = false;
				this.hudGroup.fullScreenButton.visible = false;

			}
			
			/*
			 * Hide everything and make visible what we need for the new state.
			 */
			
			if (event.newState != "Interaction")
			{
				this.scrollWorldGroupLeft = false;
				this.scrollWorldGroupRight = false;
				
				this.scrollWorldGroupDown = false;
				this.scrollWorldGroupUp = false;
			}
			
			if (event.newState != "Performance")
			{
				this.secondaryAvatarSelection = null;
				this.primaryAvatarSelection = null;
			}
			
			/*if (charInfoUIMode)
			{
				this.hudGroup.charInfoUI.currentCharacter = "";
				this.hudGroup.charInfoUI.visible = false;
			}*/
						
			
			
			if (this.worldGroup) {
				this.worldGroup.secondarySelectionCircle.visible = false;
				this.worldGroup.primarySelectionCircle.visible = false;
				this.hudGroup.clearOpinionLines();
				if(this.worldGroup.networkGroup)
					this.worldGroup.networkGroup.visible = false;
			}
			this.currentNetworkSelection = "clear";
			//go through and remove all of the relationship icons
			for each (var iconToRemove:RelationshipIcon in this.hudGroup.relationshipIcons){
				this.hudGroup.removeElement(iconToRemove);
			}
			this.hudGroup.relationshipIcons = new Vector.<RelationshipIcon>();
		
			if ("Interaction" == event.newState) 
			{	
				
				if (this.currentStory.isQuickPlay)
				{
					this.hudGroup.quickPlayInstructionsText.visible = true;
				}
				
				//This is used to update the subjective opinion words for the new UI 9-20-2012
				NEW_subjectiveOpinionManager.getInstance().clearStoredSubjectiveOpinions();
				
				this.hudGroup.goalProgressGroup.visible = false;
				
				if (!visibilityManager.useOldInterface)
				{
					//this.camera.centerTheCamera(this.currentLevel.startZoom);
					PromWeek.GameEngine.getInstance().camera.centerOnAllCharacters();
				}
				
				visibilityManager.startOfInteraction();
				visibilityManager.startOfInteraction();
				
				//this.setFocus();
				//CHECK TO SEE IF THE GAME IS OVER!!!
				//Debug.debug(this, "cif.time: " + cif.time + " time in level: " + (cif.time - this.levelStartedTime) + " endable: " + currentLevel.endable);
				
				//Shows the helpTips if the checkbox wasn't pressed before it was closed last. I am not sure if it is suppose to go here specifically
				if (hudGroup.helpTips.showTip && hudGroup.helpTips.oncePerLevel && !this.currentStory.istutorial) {
					this.hudGroup.helpTips.chooseTip(this.currentLevel.startTipIndex);
					this.hudGroup.helpTips.visible = true;
					this.hudGroup.helpTips.oncePerLevel = false;
				}
				
				//if (currentLevel.endable && (cif.time - this.levelStartedTime > this.timeBeforeEndingsAreAvailable)) 
				//{ // We are on a level where we are allowed to end things!
					//if (currentStory.evaluateEndingPreconditions(currentLevel.cast)) { // if the endings are true
						//trace ("WOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOT!!!! YOU BEAT THE GAMEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE!!!!!!!!!!!!");

					//}
				//}
				

				if (this.visibilityManager.useOldInterface)
				{
					this.hudGroup.storyGoalWindow.toDoItemAccordion.updateToDoList();
				}

				
				
			
				if (event.oldState == "LevelObjective" || event.oldState == "TutorialScreen") {
					//if the old state was LevelObjective or TutorialScreen and the new state is Interaction, center the camera at the characters.
					var characterAverageLocation:Point = new Point(0, 0)
					var avatarCount:Number = 0
					for each (a in this.worldGroup.avatars) {
						characterAverageLocation.x += a.clip.x - a.clip.width
						characterAverageLocation.y += a.clip.y - a.clip.height
						++avatarCount
						//Debug.debug(this, "onCurrentStateChange() camera at average character location: " + characterAverageLocation + " avatarCount: " + avatarCount)
					}
					characterAverageLocation.x /= avatarCount
					characterAverageLocation.y /= avatarCount
					//this.camera.centerToPoint(characterAverageLocation.x, characterAverageLocation.y)
					//@@@
					//this.camera.centerToPoint(characterAverageLocation.x, characterAverageLocation.y)
					this.camera.centerOnAllCharacters();
					
					//Debug.debug(this, "onCurrentStateChange() camera at average character location: " + characterAverageLocation + " avatarCount: " + avatarCount)
				}
				
				if (event.oldState != "" && event.oldState != "Interaction" && this.initiatorName && this.responderName) 
				{
					
					//Debug.debug(this,"Time to output triggers");
					//visualize trigger changes
					var triggerContexts:Vector.<TriggerContext> = cif.sfdb.getLatestTriggerContexts();
					var shouldDisplay:Boolean;
					//Debug.debug(this,"trigger contexts length: "+triggerContexts.length);
					var builtPred:Predicate;
					for each (var triggerContext:TriggerContext in triggerContexts)
					{
						//Debug.debug(this,"there is at least one trigger context");
						for each (var changePred:Predicate in triggerContext.getChange().predicates)
						{
							//Debug.debug(this,"onCurrentStateChange() Trigger Change Pred: "+changePred.toString());
							if (changePred.type == Predicate.STATUS)
							{
								//look at remaining time compared to DEFAULT REAMINING TIME
								shouldDisplay = true;
								var status:Status = cif.cast.getCharByName(triggerContext.initiator).getStatus(changePred.status, cif.cast.getCharByName(triggerContext.responder))
								
								//this.hudGroup.charInfoUI.updateStatusIcons();
								
								if (status)
								{
									//Debug.debug(this, "onCurrentStateChange() -------------------------");
									//Debug.debug(this, "onCurrentStateChange() " + changePred.toString());
									//Debug.debug(this, "onCurrentStateChange() remaining: " + status.remainingDuration);
									//Debug.debug(this, "onCurrentStateChange() default: " + Status.DEFAULT_INITIAL_DURATION);
									//Debug.debug(this, "onCurrentStateChange() -------------------------");
									
									if (triggerContext.getTime() == cif.time - 1)
									{
										shouldDisplay = true;
									}
									else
									{
										shouldDisplay = false;
									}
									
									/*
									 * We are currently visualizing statuses we already have if *part* of the change rule is
									 * new. For example, becoming a cheater and cheating on more than one person in a row will
									 * continue to make the cheater visualization happen. We need to make this not happen
									 */
									
								}
								
								if (shouldDisplay)
								{
									builtPred = changePred.clone();
									
									if (builtPred.primary == "initiator") builtPred.primary = triggerContext.initiator;
									else if (builtPred.primary == "responder") builtPred.primary = triggerContext.responder;
									else if (builtPred.primary == "other") builtPred.primary = triggerContext.other;
									
									if (builtPred.secondary == "initiator") builtPred.secondary = triggerContext.initiator;
									else if (builtPred.secondary == "responder") builtPred.secondary = triggerContext.responder;
									else if (builtPred.secondary == "other") builtPred.secondary = triggerContext.other;
									
									if (builtPred.tertiary == "initiator") builtPred.tertiary = triggerContext.initiator;
									else if (builtPred.tertiary == "responder") builtPred.tertiary = triggerContext.responder;
									else if (builtPred.tertiary == "other") builtPred.tertiary = triggerContext.other;
									
									//if (this.isPresentInLevel(builtPred.primary))
									//{
										//hudGroup.toDisplayChangePreds.push(builtPred);	
									//}
								}
							}
						}
					//SocialChange.currentGroup++;
					}
					

					socialGamePlaying = false;
					if (socialGameToPerform)
					{
						socialGameToPerform = null;
					}
					
					
					//camera.showWholeScene();
					//camera.freeLook();
					
					//trace("adding interaction event handlers");
					for each(a in worldGroup.avatars) 
					{
						//if (a.clip.hasEventListener(MouseEvent.CLICK))
						//	a.clip.removeEventListener(MouseEvent.CLICK, a.onClick);
						if (!a.clip.hasEventListener(MouseEvent.MOUSE_DOWN)) {
							a.clip.addEventListener(MouseEvent.MOUSE_DOWN, a.onClick);
							
							//Debug.debug(this, "onCurrentStateChange() Interaction state - adding a click event listener to " + a.characterName);
						}
						if (!a.clip.hasEventListener(MouseEvent.ROLL_OVER)) {
							a.clip.addEventListener(MouseEvent.ROLL_OVER, a.onRollOver);
						}
						if (!a.clip.hasEventListener(MouseEvent.ROLL_OUT)) {
							a.clip.addEventListener(MouseEvent.ROLL_OUT, a.onRollOut);
						}
					}
					worldGroup.currentSetting.background.addEventListener(MouseEvent.MOUSE_DOWN, worldGroup.onMouseDown);
					
					
					// now I want to see if any characters *want* to go autonomously play a game
					this.dealWithAutonomousActions();
					
					

				}
				
				// PromTimeClock visibility
				//this.hudGroup.promTimeClock.visible = true
				
				//this.hudGroup.storyGoalWindow.toDoItemAccordion.updateToDoList();
				
				for each(var aan:AutonomousActionNotifier in hudGroup.autonomousIcons) {
					aan.visible = true;
				}
			}
			else if ("Performance" == event.newState) 
			{	
				visibilityManager.startOfPerformance();
				
				
				//If the tutorial window is visible, hide it for now (we dont' want it cluttering up the performance)
				if (tutorialPopup.visible) {
					tutorialPopup.visible = false;
					if (this.tutorialFilter.visible)
					{
						this.tutorialFilterFadeOut.play([this.tutorialFilter]);
					}
				}
				
				//And in fact, let's make several things invisible here that would clutter up the screen.
				hudGroup.storyGoalWindow.visible = false;
				hudGroup.newStoryGoalWindow.visible = false;
				hudGroup.inGameOptionMenu.visible = false;
				hudGroup.skipLevelOptionMenu.visible = false;
				hudGroup.skipToEndOfPromNight.visible = false;
				hudGroup.quickPlayLevelInstructionsLabel.visible = false;
				hudGroup.resetStateButton.visible = false;
				
				
				//Maybe handle the 'click to continue' timer  here?
				currentLineOfDialogueStartTime = new Date().time;
				//Debug.debug(this, "setting current line of dialogue start time for the first time to: " + currentLineOfDialogueStartTime);
				//this.hudGroup.clickToContinueText.visible = true;
				
				worldGroup.currentSetting.background.removeEventListener(MouseEvent.MOUSE_DOWN, worldGroup.onMouseDown);
				
				if(this.enableDragPanning)
					this.worldGroup.panningEnabled = false;
				
				var initiator:Character = cif.cast.getCharByName(initiatorName);
				var responder:Character = cif.cast.getCharByName(responderName);
				
				for each(var aano:AutonomousActionNotifier in hudGroup.autonomousIcons) {
					aano.visible = false
				}
				
				if (socialGameToPerform)
				{
					var sg:SocialGame;

					
					
					//this is used to deal with the dropDown list of SGs having the initiator weight
					var startToRemove:int = socialGameToPerform.indexOf("(");
					if (startToRemove != -1)
					{
						socialGameToPerform = socialGameToPerform.substr(0, startToRemove-1);
					}


					sg = cif.socialGamesLib.getByName(socialGameToPerform);
					
					negateResponderScore = jpm.isResponderReactionNegated(initiator.characterName.toLowerCase(), responder.characterName.toLowerCase(), sg.name.toLowerCase());
					var gameEngine:PromWeek.GameEngine = PromWeek.GameEngine.getInstance();
					
					//Check to see if a specific instantiation is supposed to be forced (probably only quickPlay mode)
					var forcedInstantiationID:int = getForcedInstantiationID(sg);
					
					/**
					 * THE BIG PLAY GAME
					 * This is the cif.playGame that actually plays the game when you click on the social game button and then the characters start performing.
					 * This whole block of code used to have some if statements depending on if the responder's response had changed, but we've collapsed it all down to this!
					 */
					socialGameContext = cif.playGame(sg, initiator, responder, null, cif.cast.characters, this.currentLevel.cast, negateResponderScore, dm.getVolitionThreshold("responder"), dm.getResponderBoostFromDictionary(initiator.characterName, responder.characterName, sg.name), forcedInstantiationID);
					
					if (this.currentStory.title == "QP6")
					{
						if (cif.time == 1 
							&& socialGameContext.gameName == "Confide In" 
							&& socialGameContext.initiator.toLowerCase() == "zack"
							&& socialGameContext.responder.toLowerCase() == "naomi"
							&& socialGameContext.effectID != 29)
						{
							if (!cif.relationshipNetwork.getRelationship(RelationshipNetwork.ENEMIES, cif.cast.getCharByName("zack"), cif.cast.getCharByName("monica")))
							{
								//zack and monica are not enemies, we want to force Naomi to react in a way
								socialGameContext.effectID = 1;
							}
						}
					}
					
					
					
					if (useJuicePoints) {
						jpm.endOfTurnHandler();
					}
					//hudGroup.megaUI.clear();
					
					
					//Add a difficulty context if this is the first turn, just to make sure that we know what difficulty
					//they are playing at!
					if (cif.time == 0) {
						dm.createDifficultyContext();
					}
					
					
					
					
					//Deslect the currently selected game in the social game button ring.
					for each(var b:SocialGameButton in this.hudGroup.socialGameButtonRing.socialGameButtons) {
						b.isSelected = false;
						b.skin.invalidateProperties();
					}
					
					statisticsManager.endOfTurnHandler(socialGameContext);
					otherName = socialGameContext.other; // I think this will be useful for updating performance!
					//Debug.debug(this, "this is from social game context: " + socialGameContext.other);
					//Debug.debug(this, "This is what otherName is now set to: " + otherName);
					
					
					
					//See if I can get the other to walk someplace different (will have to keep Enter/Exit into account here, maybe?).
					/*
					 * Because others can walk in and out on a per-line-of-dialogue basis, I think it makes more sense to handle the 'Other' walking
					 * in and out code down where we handle individual lines of dialogue.
					if (otherName != null && otherName != "null" ) {
						if(currentLevel.isCharacterInThisLevel(otherName)){
							worldGroup.avatars[otherName.toLowerCase()].moveToLocation(worldGroup.avatars[initiatorName].locX, worldGroup.avatars[initiatorName].locY + 200);
						}
					}
					*/
					
					var other1:Character;
					if (socialGameContext.other != "")
					{
						other1 = cif.cast.getCharByName(socialGameContext.other);
					}
					
					/*
					for each (var gameScore:GameScore in initiator.prospectiveMemory.scores)
					{
						if (gameScore.responder.toLowerCase() == responder.characterName.toLowerCase()
							&& gameScore.name.toLowerCase() == sg.name.toLowerCase())
						{
							//Debug.debug(this,"OTHER for " + gameScore.name + ": " + gameScore.other);
							other1 = cif.cast.getCharByName(gameScore.other.toLowerCase());
						}
					}
					*/
					
					
					//update the predicate relevance info before the social changes are applied
					this.latestInitiatorPredicateRelevance = cif.getPredicateRelevance(socialGameContext, initiator, responder, other1, "initiator", this.currentLevel.cast,"positive");
					
					//this is part of splitting play game and changesocialstate in cif. I think this is OK.....
					if (cif.socialGamesLib.getByName(socialGameContext.gameName).getEffectByID(socialGameContext.effectID).isAccept)
					{
						this.latestResponderPredicateRelevance = cif.getPredicateRelevance(socialGameContext, initiator,responder, other1,"responder",this.currentLevel.cast,"accept");
					}
					else
					{
						this.latestResponderPredicateRelevance = cif.getPredicateRelevance(socialGameContext, initiator,responder, other1,"responder",this.currentLevel.cast,"reject");
					}
					
					this.hudGroup.postSGSFDBEntry.sgInfoComponent.loadSGInfoForSFDBEntryWindow(sg.name,initiator,responder,other1);
					
					//Debug.debug(this, "onCurrentStateChange() about to play a social game: " + sg.name);
					
					//this.hudGroup.megaUI.stateVisualizer.updateCharacterInfoGroup(cif.cast.getCharByName(this.currentStory.storyLeadCharacter), this.currentLevel.cast);
					
					//update every character's special role people (e.g. best friend, worst enemy, etc.).
					/*
					var avatar:Avatar;
					for each (var character:Character in cif.cast.characters)
					{
						character.updateCharacterLabels();
						for (var iii:int = 0; iii < Character.NUM_LABELS; iii++ )
						{
							Debug.debug(this,"LABELS: " + character.characterName + "'s " + Character.getLabelNameByID(iii) + " is " + character.characterLabels[iii]);
						}
					}
					*/
					
					
					//Debug.debug(this, "onCurrentStateChange() Context: " + socialGameContext);
					//Debug.debug(this, "onCurrentStateChange() Context Time: " + socialGameContext.time);
					
					var context:SocialGameContext = this.socialGameContext;// cif.sfdb.getLatestSocialGameContext();//cif.sfdb.contexts[cif.sfdb.contexts.length - 1] as SocialGameContext;
					
					//Debug.debug(this, "\nEFFECT!!!!!!!:\n" + sg.getEffectByID(context.effectID).toString() + "\n\n");
					//Debug.debug(this, "\nCONTEXT!!!!!!!:\n" + context.toXMLString() + "\n\n");
					//var context:SocialGameContext = cif.sfdb.getLatestContextTime;
					//Debug.debug(this, "onCurrentStateChange() effectID: " + context.effectID);
					

					//if there is an other involved, find who it is!
					var other:Character;
					if (context.other)
					{
						other = cif.cast.getCharByName(context.other.toLowerCase());
					}
					
					
					this.currentDialogueInstantiation = sg.getInstantiationById(sg.getEffectByID(context.effectID).instantiationID).realizeDialogue(initiator, responder, other);
					
					//now that we have realized the dialogue, we can change the state! HURRAH!
					cif.changeSocialState(socialGameContext, this.currentLevel.cast);
					
					
					this.currentLoDPartialChangeDealtWithYet = new Vector.<Boolean>();
					for each (var lod:LineOfDialogue in this.currentDialogueInstantiation.lines)
					{
						if (lod.partialChange.predicates.length > 0)
						{
							this.currentLoDPartialChangeDealtWithYet.push(false);
						}
						else
						{
							this.currentLoDPartialChangeDealtWithYet.push(true);
						}
					}
				}
				else if (endingToPerform)
				{
					
					
					var newOther:Character;
					if (endingToPerform.actualSecondThirdPair["other"] != null)
					{
						newOther = cif.cast.getCharByName(endingToPerform.actualSecondThirdPair["other"]);
					}
					this.currentDialogueInstantiation = endingToPerform.instantiations[0].realizeDialogue(cif.cast.getCharByName(endingToPerform.firstName), cif.cast.getCharByName(endingToPerform.actualSecondThirdPair["responder"]), newOther);
					
					
					
					
					this.currentLoDPartialChangeDealtWithYet = new Vector.<Boolean>();
					for each (var lod1:LineOfDialogue in this.currentDialogueInstantiation.lines)
					{
						if (lod1.partialChange.predicates.length > 0)
						{
							this.currentLoDPartialChangeDealtWithYet.push(false);
						}
						else
						{
							this.currentLoDPartialChangeDealtWithYet.push(true);
						}
					}
					var theEndingString:String;
					theEndingString = currentStory.storyLeadCharacter + "-" + endingToPerform.name;
					statisticsManager.endingsSeen[theEndingString] = true;
					
					initiatorName = endingToPerform.firstName.toLowerCase();
					responderName = endingToPerform.actualSecondThirdPair["responder"].toLowerCase();
				}
	
				//NOTE: if this goes wacky, it used to move the init to resp.locX, etc. not destinationX. I think this is better though. I think...
				Debug.debug(this, "hmmm... about to handle where the initiator is going to stand");
				//We need to figure out some important metrics to find out if the initiator should be on the left or the right.
				if (worldGroup.avatars[initiatorName].locX < worldGroup.avatars[responderName].locX)
				{
					//If the initiator is standing TOO CLOSE TO THE LEFT EDGE, have them walk to the RIGHT of the initiator (even though normally they would go to the left)
					var farLeftZoneLeftBorder:Number = worldGroup.currentSetting.zoneGrid[0][0].leftBoundary;
					if (worldGroup.avatars[responderName].locX - performanceHorizontalOffset < farLeftZoneLeftBorder) {
						worldGroup.avatars[initiatorName].moveToLocation(worldGroup.avatars[responderName].destinationX + performanceHorizontalOffset, worldGroup.avatars[responderName].destinationY);
					}
					else{
						worldGroup.avatars[initiatorName].moveToLocation(worldGroup.avatars[responderName].destinationX - performanceHorizontalOffset, worldGroup.avatars[responderName].destinationY);
					}
				}
				else
				{
					//If the initiator is standing TOO CLOSE TO THE RIGHT EDGE, have them walk to the LEFT of the initiator (even though normally they would go to the right)
					var farRightZoneLeftBorder:Number = worldGroup.currentSetting.zoneGrid[worldGroup.currentSetting.NUM_ZONE_ROWS-1][worldGroup.currentSetting.NUM_ZONE_COLS-1].leftBoundary; 
					var aZonesWidth:Number = worldGroup.currentSetting.zoneGrid[worldGroup.currentSetting.NUM_ZONE_ROWS-1][worldGroup.currentSetting.NUM_ZONE_COLS-1].width;
					var maximumXForInitiatorDuringPerformance:Number = farRightZoneLeftBorder + aZonesWidth;
					if (worldGroup.avatars[responderName].locX + performanceHorizontalOffset > maximumXForInitiatorDuringPerformance) {
						//Instead of moving to the right of the responder, as usual, move to the left!
						worldGroup.avatars[initiatorName].moveToLocation(worldGroup.avatars[responderName].destinationX - performanceHorizontalOffset, worldGroup.avatars[responderName].destinationY);	
					}
					else {
						//Move to the right of the responder, as usual.
						worldGroup.avatars[initiatorName].moveToLocation(worldGroup.avatars[responderName].destinationX + performanceHorizontalOffset, worldGroup.avatars[responderName].destinationY);	
					}
				}
				
				//this.camera.manualMode();
				
				//var cameraPosX:Number = (worldGroup.avatars[responderName].destinationX + worldGroup.avatars[initiatorName].destinationX) / 2 - worldGroup.avatars[initiatorName].clip.width
				//var cameraPosY:Number = worldGroup.avatars[initiatorName].destinationY - 150;
				
				//Debug.debug(this, "initX: " + this.worldGroup.avatars[initiatorName].destinationX);
				//Debug.debug(this, "respX: " + this.worldGroup.avatars[responderName].locX);
				//Debug.debug(this, "initY: " + this.worldGroup.avatars[initiatorName].destinationY);
				//Debug.debug(this,"respY: "+this.worldGroup.avatars[responderName].locY);
				var cameraXHackOffset:Number;
				
				//this.camera.absolutePosition(this.performanceCameraX, this.performanceCameraY);
				if (this.worldGroup.avatars[initiatorName].destinationX < this.worldGroup.avatars[responderName].locX)
				{					
					//cameraXHackOffset = performanceHorizontalOffset / 2;//-220;
					cameraXHackOffset = -320//performanceHorizontalOffset / 2;//-220;
					this.hudGroup.initiatorDiablogueBubble.pointRight = true;
					this.hudGroup.responderDiablogueBubble.pointLeft = true;
				}
				else
				{
					//cameraXHackOffset = performanceHorizontalOffset / 2;//-315;
					cameraXHackOffset = -400//-1 * performanceHorizontalOffset / 2;//-315;
					this.hudGroup.initiatorDiablogueBubble.pointLeft = true;
					this.hudGroup.responderDiablogueBubble.pointRight = true;
				}
				//old way that uses resp locX
				//var cameraX:Number = (this.worldGroup.avatars[initiatorName].destinationX + this.worldGroup.avatars[responderName].locX) / 2 
				var cameraX:Number = (this.worldGroup.avatars[initiatorName].destinationX + this.worldGroup.avatars[responderName].destinationX) / 2 
				cameraXHackOffset = cameraX * 0.01;
				cameraX -= cameraXHackOffset;

				//old way that used resp locY
				//var cameraY:Number = (this.worldGroup.avatars[initiatorName].destinationY + this.worldGroup.avatars[responderName].locY) / 2 - 75;
				var cameraY:Number = (this.worldGroup.avatars[initiatorName].destinationY + this.worldGroup.avatars[responderName].destinationY) / 2 - 75;
				
				//This little bit of code is to help us make intelligent decisions about where
				//and how the characters should move off stage when a social game is about to be played.
				//upcomingSGCamera refers to the coordinates that the camera WILL have once the social game begins playing.
				var upcomingSGCamera:PromWeek.Camera = new PromWeek.Camera();
				//upcomingSGCamera.freeLook();
				upcomingSGCamera.translate(100);
				upcomingSGCamera.zoom = performanceZoom;
				upcomingSGCamera.setWindowDimensions(this.camera.windowHeight, this.camera.windowWidth);
				upcomingSGCamera.setWorldDimensions(this.worldGroup.currentSetting.viewableHeight, this.worldGroup.currentSetting.viewableWidth);
				if (currentDialogueInstantiation.requiresOtherToPerform()) { // camera lives in a  slightly different spot depending on if it is 2 or 3 person sg.
					upcomingSGCamera.absolutePositionCenter(cameraX, cameraY - 75, otherPerformanceZoom);
				}
				else{
					upcomingSGCamera.absolutePositionCenter(cameraX, cameraY, performanceZoom);
				}

				
				

				
				
				//LETS DECIDE WHERE CHARACTERS WILL STAND AFTER A SOCIAL GAME IS PLAYED.
				for each(a in worldGroup.avatars) 
				{
					//first, just let them know that they need to find a new spot to stand, and let the
					//place where they are currently standing 'open up' to allow for different people to come in!
					a.needsToBeAssignedANewZone = true;
					Setting.settings[currentLevel.settingName].openUpAvatarZoneAndNeighbors(a);
				}
				
				//let's assign a zone to the RESPONDER!  In fact, let's make it the SAME zone that they've always been in!
				a = worldGroup.avatars[responderName.toLowerCase()]; // RESPONDER OF SG
				if (a.needsToBeAssignedANewZone) {
					if(!Setting.settings[currentLevel.settingName].placeAvatarInZone(a,
						a.currentZone.row, a.currentZone.col)) {
							Debug.debug(this, "onCurrentStateChange(), assigning zone for " + responderName.toLowerCase() + " failed");
					}
					
					locX = a.currentZone.center.x;
					//Debug.debug(this, "onCurrentStateChange() responder is: " + a.characterName + " locX is: " + locX + " zone center x is: " + a.currentZone.center.x);
					locY = a.currentZone.center.y - (a.clip.height / 2);
					a.needsToBeAssignedANewZone = false;
						
					//After our long sought after locX and locY, actually move the avatar to that new spot!
					a.homeLocX = locX;
					a.homeLocY = locY;
					//Debug.debug(this, "onNewState Results a: " + a.characterName + " homeX: " + a.homeLocX + " onNewState Results homeY: " + a.homeLocY + " zoneX: " + a.currentZone.center.x + " zoneY: " + a.currentZone.center.y);
					//a.setLocation(locX, locY);
					if ((a.characterName.toLowerCase() != initiatorName.toLowerCase() && a.characterName.toLowerCase() != responderName.toLowerCase() &&
						a.characterName.toLowerCase() != otherName.toLowerCase()) || 
						(a.characterName.toLowerCase() == otherName.toLowerCase() && !currentDialogueInstantiation.requiresOtherToPerform())){
							//Debug.debug(this, "Moving char to new location!: " + a.characterName);
							a.moveToLocation(locX, locY);
							a.destinationX = locX;
							a.destinationY = locY;
					}
				}
				
				//then assign the location of the starting lead character.
				//MAYBE WE DON'T WANT LEAD TO ALWAYS BE IN MIDDLE?
				if(STAR_SHOULD_ALWAYS_BE_IN_MIDDLE){
					a = worldGroup.avatars[currentStory.storyLeadCharacter.toLowerCase()] //LEAD CHAR OF STORY
					if (a.needsToBeAssignedANewZone) {
						if(!Setting.settings[currentLevel.settingName].placeAvatarInZone(a,
							Setting.settings[currentLevel.settingName].NUM_ZONE_ROWS / 2, Setting.settings[currentLevel.settingName].NUM_ZONE_COLS / 2)) {
								//Debug.debug(this, "loadCharacters(), assigning zone for " + currentStory.storyLeadCharacter.toLowerCase() + " failed");
							}
						//DON"T DELETE THE FOLLOWINg two lines!  They work, they just put everyone in a very rigid grid.
						//var locX:Number = a.currentZone.center.x;
						var locY:Number = a.currentZone.center.y - (a.clip.height / 2);
						
						var locX:Number = a.currentZone.getRandomXWithinZone(a);
						//var locY:Number = a.currentZone.getRandomYWithinZone(a);
						a.needsToBeAssignedANewZone = false;
						
						//After our long sought after locX and locY, actually move the avatar to that new spot!
						a.homeLocX = locX;
						a.homeLocY = locY;
						//Debug.debug(this, "onCurrentStateChange() onNewState Results a: " + a.characterName + " homeX: " + a.homeLocX + " onNewState Results homeY: " + a.homeLocY + " zoneX: " + a.currentZone.center.x + " zoneY: " + a.currentZone.center.y);
						//a.setLocation(locX, locY);
						if ((a.characterName.toLowerCase() != initiatorName.toLowerCase() && a.characterName.toLowerCase() != responderName.toLowerCase() && 
							a.characterName.toLowerCase() != otherName.toLowerCase()) || 
							(a.characterName.toLowerCase() == otherName.toLowerCase() && !currentDialogueInstantiation.requiresOtherToPerform())){
								//Debug.debug(this, "onCurrentStateChange() Moving char to new location!: " + a.characterName);
								a.moveToLocation(locX, locY);
								a.destinationX = locX;
								a.destinationY = locY;
								a.startDisappearing();
						}
					}
				}
				else { // I'm gonna say that if star isn't pre-placed, we want to compute the initiator before other people, so that they can stand next to the responder if need be.
					a = worldGroup.avatars[initiatorName.toLowerCase()]; //INITIATOR OF SG
					if (a.needsToBeAssignedANewZone) {
						var distanceDictionary:Dictionary = new Dictionary();
						for each(var potentiallyAlreadyPlacedCharacter:Character in currentLevel.cast) {
							if (potentiallyAlreadyPlacedCharacter.characterName.toLowerCase() == a.characterName.toLowerCase())
								continue; // don't bother finding the distance between a character with themselves.
							if (worldGroup.avatars[potentiallyAlreadyPlacedCharacter.characterName.toLowerCase()] && !worldGroup.avatars[potentiallyAlreadyPlacedCharacter.characterName.toLowerCase()].needsToBeAssignedANewZone) {
								//We are comparing the current character to place (a) with a character that has already been placed charAvatar.
								var rawDistance:int = worldGroup.getPreferredZoneDistance(potentiallyAlreadyPlacedCharacter, cif.cast.getCharByName(a.characterName.toLowerCase()), context);
								var actualDistance:int = worldGroup.turnRawDistanceIntoAStarDistance(worldGroup.avatars[potentiallyAlreadyPlacedCharacter.characterName.toLowerCase()], a, rawDistance, currentLevel);
								var indexName:String = a.characterName.toLowerCase() + "to" + potentiallyAlreadyPlacedCharacter.characterName.toLowerCase();
								distanceDictionary[indexName] = actualDistance;
							}
						}
						
						//Debug.debug(this, "can I just print out a dictionary I hope so: " + distanceDictionary);
						//for (var k:String in distanceDictionary) {
						//	  var value:Number=distanceDictionary[k];
						//	  var key:String = k;
							  //Debug.debug(this, "key is: " + key + " and value is: " + value);
						//}
						
						
						//OK, by this point we have an understanding of how close/far away (a) wants to be from every other character.
						//We use this information to find the perfect (or as close to perfect) zone as possible for them!
						var bestZone:Zone = worldGroup.findBestZone(distanceDictionary, currentLevel, socialGameContext);
						Setting.settings[currentLevel.settingName].placeAvatarInZone(a, bestZone.row, bestZone.col);
						
						a.needsToBeAssignedANewZone = false;
						//locX = a.currentZone.center.x;
						locY = a.currentZone.center.y - (a.clip.height / 2); // Pushes them up a little bit so that their FEET are in the center of the zone.	
						
						locX = a.currentZone.getRandomXWithinZone(a);
						//locY = a.currentZone.getRandomYWithinZone(a);
						
						a.homeLocX = locX;
						a.homeLocY = locY;
						//a.setLocation(locX, locY);
						//Only actually start moving this person is they are not going to be performing.
						if ((a.characterName.toLowerCase() != initiatorName.toLowerCase() && a.characterName.toLowerCase() != responderName.toLowerCase() && 
							a.characterName.toLowerCase() != otherName.toLowerCase()) || 
							(a.characterName.toLowerCase() == otherName.toLowerCase() && !currentDialogueInstantiation.requiresOtherToPerform())){
								//Debug.debug(this, "Moving char to new location!: " + a.characterName);
								a.moveToLocation(locX, locY);
								a.destinationX = locX;
								a.destinationY = locY;
								a.startDisappearing();
						}
					}
				}
			
				for each(a in worldGroup.avatars) { // and now, we actually do some calculations
					
					if (a.needsToBeAssignedANewZone) { //dealing with someone who DOES need to be assigned a new zone.
					
						//OK, so by this point we definitely have at least one other character placed (and maybe lots more)
						//Algorithm:
						//For the current character we need to 
						//1.)find their preferred distance from every other character.
						//2.) Then we need to find a spot that captures that distance.
						//To find 1, we go through the current state, and find a 'number' that will undoubtedly need to be tuned a lot between each pair of characters.
						distanceDictionary = new Dictionary();
						for each(potentiallyAlreadyPlacedCharacter in currentLevel.cast) {
							if (potentiallyAlreadyPlacedCharacter.characterName.toLowerCase() == a.characterName.toLowerCase())
								continue; // don't bother finding the distance between a character with themselves.
							if (worldGroup.avatars[potentiallyAlreadyPlacedCharacter.characterName.toLowerCase()] && !worldGroup.avatars[potentiallyAlreadyPlacedCharacter.characterName.toLowerCase()].needsToBeAssignedANewZone) {
								//We are comparing the current character to place (a) with a character that has already been placed charAvatar.
								rawDistance = worldGroup.getPreferredZoneDistance(potentiallyAlreadyPlacedCharacter, cif.cast.getCharByName(a.characterName.toLowerCase()), context);
								actualDistance = worldGroup.turnRawDistanceIntoAStarDistance(worldGroup.avatars[potentiallyAlreadyPlacedCharacter.characterName.toLowerCase()], a, rawDistance, currentLevel);
								indexName = a.characterName.toLowerCase() + "to" + potentiallyAlreadyPlacedCharacter.characterName.toLowerCase();
								distanceDictionary[indexName] = actualDistance;
							}
						}
						
						//Debug.debug(this, "can I just print out a dictionary I hope so: " + distanceDictionary);
						//for (k in distanceDictionary) {
						//	  value=distanceDictionary[k];
						//	  key = k;
							  //Debug.debug(this, "key is: " + key + " and value is: " + value);
						//}
						
						
						//OK, by this point we have an understanding of how close/far away (a) wants to be from every other character.
						//We use this information to find the perfect (or as close to perfect) zone as possible for them!
						bestZone = worldGroup.findBestZone(distanceDictionary, currentLevel);
						Setting.settings[currentLevel.settingName].placeAvatarInZone(a, bestZone.row, bestZone.col);
						
						a.needsToBeAssignedANewZone = false;
						//locX = a.currentZone.center.x;
						locY = a.currentZone.center.y - (a.clip.height / 2); // Pushes them up a little bit so that their FEET are in the center of the zone.					
						
						locX = a.currentZone.getRandomXWithinZone(a);
						//locY = a.currentZone.getRandomYWithinZone(a);
						
						//After our long sought after locX and locY, actually move the avatar to that new spot!
						//Don't worry, well make them 'invisible', so that they don't bother anyone!
						a.homeLocX = locX;
						a.homeLocY = locY;
						//Debug.debug(this, "onNewState Results a: " + a.characterName + " homeX: " + a.homeLocX + " onNewState Results homeY: " + a.homeLocY + " zoneX: " + a.currentZone.center.x + " zoneY: " + a.currentZone.center.y);
						//a.setLocation(locX, locY);
						if ((a.characterName.toLowerCase() != initiatorName.toLowerCase() && a.characterName.toLowerCase() != responderName.toLowerCase() && a.characterName.toLowerCase() != otherName.toLowerCase()) || (a.characterName.toLowerCase() == otherName.toLowerCase() && !currentDialogueInstantiation.requiresOtherToPerform())){
							//Debug.debug(this, "Moving char to new location!: " + a.characterName);
							a.moveToLocation(locX, locY);
							a.destinationX = locX;
							a.destinationY = locY;
							a.startDisappearing();
						}
						
					}
				}
				
				
				//This is the OLD WAY of doing it, when everyone was just standing around in a SEMI-CIRCLE
				//Now that people walk to where they are going to be instantly (and fade out as they are walking)
				//they don't need to find the 'nearest exit' any more.
				
				//Go through each charcter and see if they WILL be standing 
				//in a location where the camera is going to be able to see them.
				var p:Point = new Point();
				/*
				for each (a in worldGroup.avatars){ // And this is the old place where we dealt with this.  When the new state is 'performance.'
					if (upcomingSGCamera.willAvatarBeWhereCameraIsGoingToBe(a)) {
						//Debug.debug(this, a.characterName + " IS on camera! "); // we DO need to worry, if they aren't responder/initiator/other...
				
						//turn off character clicks
	
						// TODO: Handle smarter crosses/exits when starting a new scene.
						//OK, SOOOOOOO this is still pretty much everything that we want.
						//The big difference is we aren't just concerned with the NEAREST exit
						//we are concerned with the nearest exit that gets them in the direction of where their new location is going to be.
						if (a.characterName.toLowerCase() != initiatorName.toLowerCase() && 
							a.characterName.toLowerCase() != responderName.toLowerCase() &&
							a.characterName.toLowerCase() != otherName.toLowerCase())
						{
							//a.clip.alpha = 0.3;
							//This is where we want to handle smarter leaving of the scene
							//i.e. only leave the scene if you are going to be caught 'on camera'
							//Debug.debug(this, "Moving " + a.characterName + " to a sensible, nearby off-camera location");
							p = upcomingSGCamera.nearestExit(a);
							a.moveToLocation(p.x, p.y);
							//a.moveToLocation(a.locX, a.locY + 500); // change this line to something smarter
						}	
						if (a.characterName.toLowerCase() == otherName.toLowerCase() && !currentDialogueInstantiation.requiresOtherToPerform()) { 
							// we don't need a performing other!  We can move the other too!
							p = upcomingSGCamera.nearestExit(a);
							a.moveToLocation(p.x, p.y);
							//a.moveToLocation(a.locX, a.locY + 500); // change this line to something smarter
						}				
					}
					else {
						//Debug.debug(this, a.characterName + " NOT on camera! "); // we don't need to worry
					}
				}
				*/
				
				//Let's remember what the old zoom was before we jump into performance zoom.
				this.camera.previousZoom = this.camera.currentZoom;
				if(currentDialogueInstantiation.requiresOtherToPerform()){
					this.camera.absolutePositionCenter(cameraX, cameraY - 75, otherPerformanceZoom);
				}
				else {
					this.camera.absolutePositionCenter(cameraX, cameraY, performanceZoom);
				}
				
				
				
				//HANDLE TELEPORT OF INITIATOR
				//In large levels (e.g. the prom), it can be a pain to wait for a character to have to walk all the way to the other
				//side of the screen to interact with someone.
				//What we are going to do, is check to see if the initiator is already "on screen" when the camera zooms in for performance,
				//and if they aren't, move the initiator (or the responder) just off screen and then have them walk in, so that there isn't
				//a long delay.
				//Debug.debug(this, "gameEngine onCurrentStateChange() camera stuff. cameraX: " + cameraX + " cameraY: " + cameraY);
				//Debug.debug(this, "gameEngine onCurrentStateChange() OK -- let's try doing it with 'normal' camera stuff");
				if (this.camera.isAvatarCurrentlyWhereCameraIsGoingToBe(worldGroup.avatars[initiator.characterName.toLowerCase()])) {
					//Debug.debug(this, "TRUE! Avatar WAS on camera!  No teleportation was necessary!");
				}
				else {
					//Debug.debug(this, "FALSE! Avatar was NOT on camera! Teleportation would have been nice!");
					//So, I guess this is where we should handle teleportation, huh?
					worldGroup.avatars[initiator.characterName.toLowerCase()].handleTeleport(camera, cameraX, cameraY);
				}
				tempCameraX = cameraX; // used to help us out with 'other performance' down the road!
				tempCameraY = cameraY; // because 'others' may need to get teleported, too!
				
				
				//Debug.debug(this, "AFTER ABSOLUTE POSITION REAL destination camera X: " + this.camera.destinationInWorldCoordinates.x + " REAL camera Y: " + this.camera.destinationInWorldCoordinates.y);
				
				
				//Debug.debug(this, "onCurrentStateChange() calculated camera position: <" + cameraX + ", " + cameraY + ">");
				//var r:Rect = new Rect();
				//r.x = cameraX;
				//r.y = cameraY;
				//r.width = 10;
				//r.height = 10;
				//r.fill = new SolidColor(0xff00ff);
				//this.worldGroup.addElement(r);
				//
				//this.camera.zoom = performanceZoom;
				//hudGroup.socialGameResultsUI.visible = true;
				
				//this.hudGroup.promTimeClock.visible = false
			}
			else if ("Results" == event.newState)
			{
				//If we are in a tutorial level, make the tutorial window show up again after hiding it for the performance.
				if (this.currentLevel.isTutorial && !tutorialPopup.visible) 
				{
					if (!this.tutorialStopped)
					{
						tutorialPopup.visible = true;
					}
				}
				
				//This is where we USED to tell everybody to go stand in their home location, but now we take care of that as soon as Performance starts (above).
				//Now all we have to do is tell everyone to start re-appearing.
				for each(a  in worldGroup.avatars) 
				{
					a.startReappearing();
					
					/*
					// TODO: Have characters not return to a "Home" Location, but to a place that they actually want to stand after a social game.
					//ORRRRR  By this point, have their 'home' location already be computed to be something intelligent that they want to stand in!
					if (a.characterName.toLowerCase() != initiatorName.toLowerCase() && 
						a.characterName.toLowerCase() != responderName.toLowerCase() &&
						a.characterName.toLowerCase() != otherName.toLowerCase())
					{
						//a.clip.alpha = 1.0;
						//Debug.debug(this, "Interaction mode -- move back " + a.characterName);
						//Debug.debug(this, "other name is: " + otherName);
						//a.moveToLocation(a.locX, a.locY - 500);
						a.moveToLocation(a.homeLocX, a.homeLocY);
					}
					if (a.characterName.toLowerCase() == otherName.toLowerCase() && !currentDialogueInstantiation.requiresOtherToPerform()) { 
						// we didn't have a performing other!  We need to move the other too!
						//a.moveToLocation(a.locX, a.locY - 500);	
						a.moveToLocation(a.homeLocX, a.homeLocY);
					}
					*/
					
					//PromWeek::GameEngine: onNewState Results a: jordan homeX: 685.2 onNewState Results homeY: 782.65 zoneX: 927.2 zoneY: 1180.5
					//PromWeek::GameEngine: onNewState Results a: zack homeX: 443.2 onNewState Results homeY: 1008.275 zoneX: 443.2 zoneY: 1180.5
				}
				if (!endingToPerform)
				{
					//Debug.debug(this, "TRIGGERS: " + cif.sfdb.triggers.length);
					//Debug.debug(this, "STORY TRIGGERS: " + cif.sfdb.storyTriggers.length);
					
					
					if (!this.displayGoalProgressNotifications)
					{
						this.displayGoalProgressNotifications = true;
					}
					
					
					this.levelTimeRemaining--;
					//I think, in case there is an autonomous action or something at the end,
					//we want to make sure the levelTimeRemaining never goes below zero.
					this.levelTimeRemaining = Math.max(this.levelTimeRemaining, 0);
					//Debug.debug(this,"LEVEL TIME REMAINING: " + this.levelTimeRemaining);
					this.hudGroup.megaUI.levelClock.setTimeRemaining(this.levelTimeRemaining);
					
					context = this.socialGameContext;//cif.sfdb.getLatestSocialGameContext();//cif.sfdb.contexts[cif.sfdb.contexts.length - 1] as SocialGameContext;
					
					//sg = cif.socialGamesLib.getByName(socialGameToPerform);

					//var initiator:Character = cif.cast.getCharByName(initiatorName);
					//var responder:Character = cif.cast.getCharByName(responderName);

					//var responderScore:Number = cif.scoreResponderWithMicrotheories(sg, initiator, responder);

					//var effect:Effect = cif.getSalientEffect(sg, responderScore>=0, initiator, responder);

					//reset the megaUI's selections
					//this.hudGroup.megaUI.resetMegaUISelections();

					var effect:Effect = cif.socialGamesLib.getByName(context.gameName).getEffectByID(context.effectID);
					
					hudGroup.postSGSFDBEntry.createSocialGameEntry(context);
					
					hudGroup.setDebugInfo(context);
					//Debug.debug(this,"Debug Info Set!");
					
					//Make a helpful little tool tip show up between levels!
					if (useBetweenTurnHints)
					{
						this.hudGroup.betweenTurnHint.visible = true;
						this.hudGroup.betweenTurnHint.text =   this.hudGroup.helpTips.getTipStringFromIndex(this.hudGroup.helpTips.getRandomTipIndex());
					}
					
					
					//hudGroup.socialGameResultsUI.resultsRichText.text = effect.toString();//sg.effects[context.effectID].toString();
					var otherChar:Character;
					var otherName:String = "";
					if (context.other)
					{
						otherChar = context.getOther();
						otherName = otherChar.characterName;
					}
					
					hudGroup.socialGameResultsUI.perfromanceRealizationStringRichText.text = effect.renderTextNotForDialogue(context.getInitiator(), context.getResponder(), otherChar);
					var pred:Predicate;
					hudGroup.socialGameResultsUI.whatHappenedListRichText.text = "";
					
					//some temp variables for not duplicating mediums in the results screen.
					//Kind of depends on the two of them being right next to each in the list,
					//otherwise the 'low' of one might eliminate the 'high' of another.
					var medLow:Boolean = false; // Specifically looking for the number 33
					var medHigh:Boolean = false; // Specifically looking for the number 66
					var justificationsToDisplay:int = 6;
					for each(pred in effect.change.predicates)
					{
						if (pred.type == Predicate.RELATIONSHIP
							|| (pred.type == Predicate.STATUS && (pred.status < Status.FIRST_TO_IGNORE_NON_DIRECTED || pred.status >= Status.FIRST_DIRECTED_STATUS))
							|| pred.type == Predicate.NETWORK
							|| (pred.type == Predicate.SFDBLABEL && pred.sfdbLabel < SocialFactsDB.FIRST_STORY_SEQUENCE))
						{
							var primaryName:String = pred.primary;
							var secondaryName:String = pred.secondary;
							var tertiarynName:String = pred.tertiary;
							
							/*
							switch(primaryName) {
								case 'initiator': primaryName = context.getInitiator().characterName; break;
								case 'responder': primaryName = context.getResponder().characterName; break;
								case 'other': primaryName = context.getOther().characterName; break;
								default: primaryName = "Dunno who primary is";
							}
							switch(secondaryName) {
								case 'initiator': secondaryName = context.getInitiator().characterName; break;
								case 'responder': secondaryName = context.getResponder().characterName; break;
								case 'other': secondaryName = context.getOther().characterName; break;
								default: secondaryName = "Dunno who secondary is";
							}
							switch(tertiarynName) {
								case 'initiator': tertiarynName = context.getInitiator().characterName; break;
								case 'responder': tertiarynName = context.getResponder().characterName; break;
								case 'other': tertiarynName = context.getOther().characterName; break;
								default: tertiarynName = "Dunno who tertiarynName is";
							}
							*/
							
							
							//Make sure that everything turns out 
							//hudGroup.socialGameResultsUI.whatHappenedListRichText.text += pred.toString() + "\n"
							if (pred.primary == "initiator") {
								if (pred.secondary == "other") { // The initiator of this social game has some predicate connection to the other of the social game.
									hudGroup.socialGameResultsUI.whatHappenedListRichText.text += pred.toNaturalLanguageString(initiatorName, otherName, otherName) + "\n";
								}
								else if(pred.secondary == "responder") {// The initiator of this social game has some predicate connection to the responder of the social game.
									hudGroup.socialGameResultsUI.whatHappenedListRichText.text += pred.toNaturalLanguageString(initiatorName, responderName, otherName) + "\n";
								}
								else if (pred.secondary == "") { // Probably an undirected status call.
									hudGroup.socialGameResultsUI.whatHappenedListRichText.text += pred.toNaturalLanguageString(initiatorName, " ", " ") + "\n";
								}
								else { //Default case
									trace ("Unaccounted secondary role when determining What Just Happened on the results screen. (initiator was primary)"); 
								}
							}
							else if (pred.primary == "responder") {
								if (pred.secondary == "initiator") { // The responder of this social game has some predicate connection to the initiator of the social game.
									hudGroup.socialGameResultsUI.whatHappenedListRichText.text += pred.toNaturalLanguageString(responderName, initiatorName, otherName) + "\n";
								}
								else if (pred.secondary == "other") { // The responder of this social game has some predicate connection to the other of the social game.
									hudGroup.socialGameResultsUI.whatHappenedListRichText.text += pred.toNaturalLanguageString(responderName, otherName, otherName) + "\n";
								}
								else if (pred.secondary == "") { // Probably an undirected status call.
									hudGroup.socialGameResultsUI.whatHappenedListRichText.text += pred.toNaturalLanguageString(responderName, " ", " ") + "\n";
								}
								else { //Default case
									trace ("Unaccounted secondary role when determining What Just Happened on the results screen. (responder was primary)"); 
								}
							}
							else{
								Debug.debug(this, "onCurrentStateChange() OH OH DON'T KNOW WHAT TO DO INSIDE OF GAMEENGINE RESULTS SCREEN! I bet OTHER was the primary in a predicate change");
							}
							
							
							//UPDATE THE SOCIAL CHANGE RECORD
							var triggerSocialChange:SocialChange = new PromWeek.SocialChange();
							triggerSocialChange.populateFromSGContext(context, pred);
							triggerSocialChange.groupID = SocialChange.currentGroup;
							hudGroup.postSGSFDBEntry.sgChangeRecord.socialChanges.push(triggerSocialChange);
							//hudGroup.postSGSFDBEntry.sgChangeRecord.setIndexToEnd();
							//hudGroup.postSGSFDBEntry.sgChangeRecord.nextOne();
							
						} // end if pred == trait, stat, or rel.
					} // end for each pred in effect.changes.
					//hudGroup.postSGSFDBEntry.sgChangeRecord.rewindToBeginning(); // Maybe this will fix the display issues?
					hudGroup.postSGSFDBEntry.sgChangeRecord.initialBoxFill(); // Maybe this will fix the display issues?
					//hudGroup.postSGSFDBEntry.sgChangeRecord.prev(); // Maybe this will fix the display issues?
					SocialChange.currentGroup++; // we are now ready for our next grouping (i.e. next socialChanges will be from a different social game or a trigger).
					
					
					for each(var d:Dictionary in getInitiatorMotives(context)) {
						hudGroup.postSGSFDBEntry.initiatorMotives += d["percent"] + "% " + d["motive"] + "\n";
					}
					
					
					for each(d in getResponderMotives(context)) {
						hudGroup.postSGSFDBEntry.initiatorMotives += d["percent"] + "% " + d["motive"] + "\n";
					}
					
					
					//Add all triggers that fired at this time to the sfdbEntry social change record for triggers
					var triggerContexts2:Vector.<TriggerContext> = cif.sfdb.getTriggerContextsAtTime(cif.time - 1); //was cif.time - 1
					var triggersWeHaveAlreadyAdded:Dictionary = new Dictionary();
					var indexString:String;
					var okToAddStatus:Boolean;
					for each (triggerContext in triggerContexts2)
					{
						for each (pred in triggerContext.getChange().predicates)
						{
							okToAddStatus = true;
							if (pred.type == Predicate.STATUS && pred.status >= Status.FIRST_TO_IGNORE_NON_DIRECTED && pred.status < Status.FIRST_DIRECTED_STATUS)
							{
								okToAddStatus = false;
							}
							
							if (okToAddStatus)
							{
								indexString = pred.primary + pred.secondary + Status.getStatusNameByNumber(pred.status);
								if (!triggersWeHaveAlreadyAdded[indexString])
								{
									var triggerSocialChange1:SocialChange = new PromWeek.SocialChange();
									if (pred.status != Status.HOMEWRECKED)
									{
										
										//if (pred.status == Status.ANNOYED_WITH)
										//{
											//var tretret:Trigger = cif.sfdb.getTriggerByID(triggerContext.id);
											//trace("---------");
										//}
										triggerSocialChange1.populateFromTriggerContext(triggerContext, pred);
									
										triggerSocialChange1.groupID = SocialChange.currentGroup;
										triggersWeHaveAlreadyAdded[indexString] = true;
										hudGroup.postSGSFDBEntry.triggerChangeRecord.socialChanges.push(triggerSocialChange1);
										hudGroup.postSGSFDBEntry.triggerChangeRecord.setIndexToEnd();
										hudGroup.postSGSFDBEntry.triggerChangeRecord.nextOne();
									}
								}
							}
						}
					}
					if (hudGroup.postSGSFDBEntry.triggerChangeRecord.socialChanges.length < 1)
					{
						hudGroup.postSGSFDBEntry.triggerChangeRecord.alpha = 0;
						hudGroup.postSGSFDBEntry.falloutLabel.alpha = 0;
						
						hudGroup.postSGSFDBEntry.changesGroup.y = hudGroup.postSGSFDBEntry.noTriggerRecordPosition;
					}
					else
					{
						hudGroup.postSGSFDBEntry.changesGroup.y = hudGroup.postSGSFDBEntry.triggerRecordPosition;
						hudGroup.postSGSFDBEntry.triggerChangeRecord.alpha = 1;
						hudGroup.postSGSFDBEntry.triggerChangeRecord.visible = true;
						hudGroup.postSGSFDBEntry.falloutLabel.alpha = 1;
					}
					//Debug.debug(this, "We Attempted to add triggers to sfdb entry!");
					
					

					hudGroup.postSGSFDBEntry.visible = true;
					
					
					//this.validateDisplayList();
					//this.hudGroup.validateDisplayList();
					//this.worldGroup.validateDisplayList();
					
					if (this.currentLevel.evaluateGoals()) 
					{
						//Debug.debug(this, "currentLevel's goals evaluated to true!");
						this.areLevelGoalsSatisfied = true;
						this.hudGroup.megaUI.levelClock.setGoalAchieved(true);
					}
					
					if (!this.isFormingIntent)
					{
						//var castLength:Number =  currentLevel.cast.length;
						//hudGroup.initIntentProgressBar(this.cif.socialGamesLib.games.length* this.currentLevel.cast.length * (this.currentLevel.cast.length-1));
						hudGroup.initIntentProgressBar( this.currentLevel.cast.length * this.currentLevel.cast.length);
						hudGroup.intentProgressBar.visible = true;
						cif.clearProspectiveMemory();
						
						//Debug.debug(this,"clearProspectiveMemory happened!");
						
						this.intentInitiatorIterator = 0;
						this.intentResponderIterator = 0;
						this.intentSGIterator = 0;
						this.isFormingIntent = true;
						
						this.startIntentTime = new Date().time;
					}
				}
				else
				{
					//increment which ending we are looking at
					this.endingIndex++;
					if (this.endingIndex >= this.possibleEndings.length)
					{
						this.currentState = "EndOfStory";
						
						/*
						//if we have run out of endins to show
						//NOTE: this logic needs to be revisited now that we are stringing these together
						var closingString:String = "";
						if (statisticsManager.endingsSeen[currentStory.storyLeadCharacter + "-" + endingToPerform.name]) {
							closingString = "Congratulations on getting through the week!  Push 'Return to Main Menu' to see if any new Prom Adventures await you!" 
						}
						else {
							closingString = "Congratulations!  You just unlocked a new ending: " + endingToPerform.name + "!  Push 'Return to Main Menu' to see if any new Prom Adventures await you!";
							statisticsManager.endingsSeen[currentStory.storyLeadCharacter + "-" + endingToPerform.name] = true;
						}
						Alert.buttonWidth = 150
						Alert.okLabel = "Return to Main Menu";
						Alert.show(closingString, "Congratulations!", Alert.OK, null, sawEnding);
						*/
					}
					else
					{
						this.possibleEndings[this.endingIndex].actualSecondThirdPair = this.endingPickedPairs[this.endingIndex];
						this.hudGroup.launchEndingSequence(this.possibleEndings[this.endingIndex], this.endingPickedPairs[this.endingIndex]);
						this.hudGroup.endingInfoWindow.updateEndingText(this.possibleEndings[this.endingIndex]);
						this.hudGroup.endingInfoWindow.visible = true;
						this.hudGroup.endingInfoWindow.alpha = 1;
					}
				}
			}
			else if ("Pause" == event.newState) 
			{
				
			} else if ("StorySelection" == event.newState) {
				//create the sfdbEntries for backstories
				this.hudGroup.mainMenuScreen.continuePopUp.visible = false;
				StatisticsManager.getInstance().resetRelationshipStats();
				this.hudGroup.storySelectionScreen.updateNewlyUnlockedCampaigns();
				hudGroup.storySelectionScreen.visible = true;
				hudGroup.storySelectionScreen.checkForProgress();
				
				hudGroup.tutorialSelectionScreen.visible = false;
				hudGroup.sandboxMenuScreen.visible = false;
				
				/*
				if(statisticsManager.endingXML)
					//hudGroup.storySelectionScreen.storyDescription.text += statisticsManager.endingXML.toString();
				else {
					//hudGroup.storySelectionScreen.storyDescription.text += "ending XML was null!";
				}
				//hudGroup.storySelectionScreen.storyDescription.text += "And this is the data string: " + statisticsManager.endingDataString;
				*/
			} 
			else if ("MainMenu" == event.newState) {
				
				hudGroup.mainMenuScreen.visible = true;
				hudGroup.tutorialSelectionScreen.visible = false;
				hudGroup.sandboxMenuScreen.visible = false;
				hudGroup.storySelectionScreen.visible = false;
				hudGroup.creditsScreen.visible = false;
				this.hudGroup.mainMenuScreen.continuePopUp.visible = false;
				if (hudGroup.mainMenuScreen.continueButton) {
					hudGroup.mainMenuScreen.continueButton.enabled = false;
				}
				//get the story continue level trace from the backend
				Utility.log(this, "onCurrentStateChange() going to the MainMenu state.");
				if(this.getContinueLevelTrace)
					this.backend.getContinueLevelTrace();
				this.setContinueButtonState();
			}
			else if ("TutorialScreen" == event.newState) {
				hudGroup.tutorialSelectionScreen.visible = true;
				hudGroup.sandboxMenuScreen.visible = false;
				hudGroup.storySelectionScreen.visible = false;
				hudGroup.creditsScreen.visible = false;
				this.hudGroup.mainMenuScreen.continuePopUp.visible = false;
			}
			else if ("SandboxMenu" == event.newState) {
				
				//trace(cif.socialGamesLib.getByName("Let's Be Friends!").toNaturalLanguage());
				
				
				hudGroup.sandboxMenuScreen.visible = true;
				hudGroup.tutorialSelectionScreen.visible = false;
				hudGroup.storySelectionScreen.visible = false;
				hudGroup.creditsScreen.visible = false;
				this.hudGroup.mainMenuScreen.continuePopUp.visible = false;
				this.hudGroup.sandboxMenuScreen.continueButton.enabled = false;
				this.hudGroup.sandboxMenuScreen.setToggleButtonsToStateVisualizer();
				//get the replay conintue level trace from the backend if we don't have one stored locally
				if(this.getFreeplayLevelTrace)
					this.backend.getFreeplayState();
				this.setFreeplayButtonState();
				
			}
			else if ("FacadeState" == event.newState) {
				trace("EASTER EGG!");
				this.hudGroup.mainMenuScreen.visible = false;
				this.hudGroup.mainMenuScreen.continuePopUp.visible = false;
				StatisticsManager.getInstance().resetRelationshipStats();
				this.hudGroup.storySelectionScreen.visible = false;
				
				this.hudGroup.tutorialSelectionScreen.visible = false;
				this.hudGroup.sandboxMenuScreen.visible = false;
				
				this.hudGroup.facadeScreen.fadeIn.play([this.hudGroup.facadeScreen]);
			}
			else if ("OptionsMenu" == event.newState) {
				hudGroup.optionsScreen.visible = true;
			}
			else if ("AchievementsMenu" == event.newState) {
				hudGroup.achievementsScreen.visible = true;
			}
			else if ("CreditsMenu" == event.newState) {
				hudGroup.tutorialSelectionScreen.visible = true;
				hudGroup.sandboxMenuScreen.visible = false;
				hudGroup.storySelectionScreen.visible = false;
				hudGroup.creditsScreen.visible = true;
				this.hudGroup.mainMenuScreen.continuePopUp.visible = false;
			}
			else if ("LevelObjective" == event.newState) 
			{ // shows up at the start of every level, teling you what to do
				//this.hudGroup.addElement(this.hudGroup.levelObjectiveScreen);
				// SFDB Visualizer!
				var sfdbEntry1:SFDBEntry;
				this.socialGamePlaying = false;
				this.setDimensions(this.APPLICATION_WIDTH, this.APPLICATION_HEIGHT, this.APPLICATION_SCALE);
				
				//for each (var context7:SFDBContext in cif.sfdb.contexts)
				//{
					//sfdbEntry1 = new PromWeek.SFDBEntry();
				//}
					//sfdbEntry1.createSFDBEntryComponent(context7);
				//Debug.debug(this,"----------------------------------------------------------------------------------");
				//this.activateLevel(this.currentLevelIndex + 1);
				
				if (this.useLevelObjectiveScreen)
				{
					this.hudGroup.levelObjectiveScreen.setLevelObjectiveText(currentLevel.title, (currentLevel.description + "\n\n" + this.getStoryTidBit()));
				}
				else
				{
					this.hudGroup.levelObjectiveScreen.setLevelObjectiveText("", "");
				}
				this.hudGroup.levelObjectiveScreen.alpha = 1.0;
				this.hudGroup.levelObjectiveScreen.clickToBegin.visible = false;
				this.hudGroup.levelObjectiveScreen.visible = true;
				this.hudGroup.levelResultsScreen.visible = false;
				this.hudGroup.helpTips.oncePerLevel = true; //Whenever the level objective screen shows up then the helptips can show up again.
				this.firstIntentHasBeenFormed = false;
				if (!this.firstIntentHasBeenFormed)
				{
					castLength =  currentLevel.cast.length;
					//hudGroup.initIntentProgressBar(this.cif.socialGamesLib.games.length* this.currentLevel.cast.length * (this.currentLevel.cast.length-1));
					hudGroup.initIntentProgressBar( this.currentLevel.cast.length * this.currentLevel.cast.length);
					hudGroup.intentProgressBar.visible = true;
					cif.clearProspectiveMemory();
					
					this.intentInitiatorIterator = 0;
					this.intentResponderIterator = 0;
					
					this.intentSGIterator = 0;
					Debug.debug(this, "onCurrentStateChange() LevelObjective is new state - start forming intent.");
					
					this.startIntentTime = new Date().time;
					this.isFormingIntent = true;
					
					//run the triggers for the first time!
					//push the first set of triggers one step into the past so the initial triggers don't show up
					//right after the first social game played.
					cif.time--;
					cif.sfdb.runTriggers(this.currentLevel.cast);
					cif.sfdb.runTriggers(this.currentLevel.cast);
					cif.time++;
					
					for each (a in this.worldGroup.avatars) {
						if(initiator && responder)
							if(initiator.characterName != a.characterName || responder.characterName != a.characterName) 
								a.moveToLocation(a.locX, a.locY + 500);
							}
					}
				
				this.onClickInLevelObjectiveState();
				
			}
			else if ("LoadingLevel" == event.newState) {
				//this.isLevelFinished = false;
				//Debug.debug(this, "****************************************** We have initialized the level!");
				/**
				 * The logic for transitioning levels should be here.
				 */
				this.activateLevel(this.currentLevelIndex + 1);
				//need to form intent for the new level
				
				//this.finishedLoading = false;
				this.currentState = "LevelObjective";
			}
			else if ("EndOfLevelResult" == event.newState) 
			{ // after you click on the level clock, shows you interesting things about what you did.
				trace("End of level screen");
			
				
				this.dealWithEndingLevelStuff("endOfLevel");
				this.hudGroup.storyGoalWindow.visible = false;
				hudGroup.newStoryGoalWindow.visible = false;
				this.hudGroup.levelResultsScreen.visible = true;
					hudGroup.newStoryGoalWindow.closeButton.visible = false;
					hudGroup.newStoryGoalWindow.bgShape.visible = false;
					hudGroup.newStoryGoalWindow.goalTitleGroup.visible = false;
					hudGroup.newStoryGoalWindow.visible = true;
			}
			else if (event.newState == "EndOfStory")
			{
				this.hudGroup.endOfStoryScreen.setAvatar(this.currentStory.storyLeadCharacter);
								
				this.dealWithEndingLevelStuff("endOfStory");

				this.hudGroup.endOfStoryScreen.updateEndOfStoryScreen();
				this.hudGroup.endOfStoryScreen.visible = true;
			}
		}
		
		

		
		
		
		/**
		 * Intended to be called by the StateChangeEvent handler, this function sets the background
		 * music acoording to the newly-reached state right as the state is changing.
		 * 
		 * @param	e	The event with the state change information.
		 */
		public function setMusicByStateChange(e:StateChangeEvent):void {
		
		//<s:State name="MainMenu"/>
		//<s:State name="StorySelection"/>
		//<s:State name="OptionsMenu"/>
		//<s:State name="AchievementsMenu"/>
		//<s:State name="CreditsMenu"/>
		//<s:State name="TutorialScreen"/>
		//<s:State name="LevelObjective"/>
		//<s:State name="Interaction"/>
		//<s:State name="Performance"/>
		//<s:State name="Results"/>
		//<s:State name="Pause"/>
		//<s:State name="EndOfLevelResult" />
		//<s:State name="LoadingLevel" />
		//<s:State name="EndOfStory" />
		//<s:State name="SandboxMenu" />
			//
			//volumes and offsets
			switch(e.newState) {
				case "MainMenu":
					if (!titleMusicFirstTime) {
						MusicPlayer.getInstance().musicOffsets[MusicPlayer.TITLE] = MusicPlayer.TITLE_REPLAY_OFFSET;
					}
					break;
				case "StorySelection":
				case "OptionsMenu":
				case "AchievementsMenu":
				case "CreditsMenu":
				case "TutorialScreen":
				case "LevelObjective":
				case "EndOfLevelResult":
				case "LoadingLevel":
					break;
				case "EndOfStory":
					break;
				case "Interaction":
					Utility.log(this, "setMusicByStateChange() starting interaction fade.");
					TweenLite.to(MusicPlayer, MusicPlayer.FADE_DURATION, { volume:MusicPlayer.HIGH_VOLUME} );
					break;
				case "Performance":
					Utility.log(this, "setMusicByStateChange() starting performance fade.");
					TweenLite.to(MusicPlayer, MusicPlayer.FADE_DURATION, { volume:MusicPlayer.LOW_VOLUME } );
					break;
				case "Results":
					break;
				case "SandboxMenu":
					break;
				case "EndOfStory":
					break;
			}

		
			//music selection
			switch(e.newState) {
				case "MainMenu":
					MusicPlayer.playMusic(MusicPlayer.TITLE);
					this.titleMusicFirstTime = false;
					break;
				case "StorySelection":
				case "OptionsMenu":
				case "AchievementsMenu":
				case "CreditsMenu":
				case "TutorialScreen":
				case "EndOfLevelResult":
				case "LoadingLevel":
				case "EndOfStory":
				case "SandboxMenu":
				case "EndOfStory":
					MusicPlayer.playMusic(MusicPlayer.LEVEL);
					break;
				case "LevelObjective":
				case "Interaction":
				case "Performance":
				case "Results":
					if (this.currentLevel.endable)
					{
						MusicPlayer.playMusic(MusicPlayer.PROM);
					}
					else
					{
						MusicPlayer.playMusic(MusicPlayer.GAMEPLAY);
					}
					break;
			}
			
		}
		/**
		 * Sets the state of the Continue button in the main menu depending on the contents of the
		 * stored continue level trace XML file.
		 */
		public function setFreeplayButtonState():void {
			//the case where the XML has not been set yet.
			if (!this.freeplayLevelTraceXML) {
				this.getFreeplayLevelTrace = true;
				this.hudGroup.sandboxMenuScreen.continueButton.enabled = false;
				return;
			}
			this.getFreeplayLevelTrace = false;
			//determine if the level trace is continuable
			if (this.freeplayLevelTraceXML.@empty == "true") {
				this.freeplayLevelTraceXML = null;
				this.hudGroup.sandboxMenuScreen.continueButton.enabled = false;
			}else {
				//update the game engine's UI state with the new continue level trace
				//if ()
				this.hudGroup.sandboxMenuScreen.continueButton.enabled = true;
			}
		}
		
		/**
		 * Sets the state of the Continue button in the main menu depending on the contents of the
		 * stored continue level trace XML file.
		 */
		public function setContinueButtonState():void {
			if (!this.continueLevelTraceXML) {
				this.getContinueLevelTrace = true;
				this.hudGroup.mainMenuScreen.continueButton.enabled = false;
				return;
			}
			this.getContinueLevelTrace = false;
			//determine if the level trace is continuable
			if (this.continueLevelTraceXML.@empty == "true") {
				this.continueLevelTraceXML = null;
				this.hudGroup.mainMenuScreen.continueButton.enabled = false;
			}else {
				//update the game engine's UI state with the new continue level trace
				//if ()
				this.hudGroup.mainMenuScreen.continueButton.enabled = true;
			}
		}
		
		public function addCharToLevelOffScreen(charName:String):void
		{
			var name:String = charName.toLowerCase();
			charName = name;
			
			if (this.currentLevel.endable)
			{
				charName = charName + "Prom";
			}
			
			this.worldGroup.avatars[name] = new Avatar(resourceLibrary.characterClips[charName]);
			this.worldGroup.avatars[name].characterName = name;
			this.worldGroup.avatars[name].clip.addEventListener(MouseEvent.MOUSE_DOWN, this.worldGroup.avatars[name].onClick, false);
			this.worldGroup.avatars[name].clip.addEventListener(MouseEvent.ROLL_OVER, this.worldGroup.avatars[name].onRollOver, false);
			this.worldGroup.avatars[name].clip.addEventListener(MouseEvent.ROLL_OUT, this.worldGroup.avatars[name].onRollOut, false);
			
			//this is where more sophisticated placement code should go for the character.
			Setting.settings[currentLevel.settingName].placeAvatarInZone(this.worldGroup.avatars[name], Setting.settings[currentLevel.settingName].NUM_ZONE_ROWS/2, Setting.settings[currentLevel.settingName].NUM_ZONE_COLS/2);
			var locX:Number = Utility.randRange(this.worldGroup.avatars[name].clip.width + 50, this.worldGroup.currentSetting.viewableWidth - this.worldGroup.avatars[name].clip.width - 50);
			var locY:Number = this.worldGroup.currentSetting.viewableHeight - this.worldGroup.currentSetting.horizonHeight/2// - this.worldGroup.avatars[name].clip.height;
			
			this.worldGroup.avatars[name].homeLocX = locX;
			this.worldGroup.avatars[name].homeLocY = locY;
			this.worldGroup.avatars[name].setLocation(locX, locY);
			this.worldGroup.avatars[name].moveToLocation(locX, locY);
			this.worldGroup.avatars[name].destinationX = locX;
			this.worldGroup.avatars[name].destinationY = locY;

			this.worldGroup.avatars[name].lookingAtTarget = "left";
			this.worldGroup.avatars[name].facing = Avatar.LEFT;
			this.worldGroup.avatars[name].homeTargetLookingDirection = "left";
			
			this.worldGroup.addElement(this.worldGroup.avatars[name]);
		}

		
		
		public function charInLevel(charName:String):Boolean
		{
			for each (var avatar:Avatar in this.worldGroup.avatars)
			{
				if (avatar.characterName.toLowerCase() == charName.toLowerCase())
				{
					return true;
				}
			}
			return false;
		}
		
		
		/**
		 * 
		 * @param	continuable True if there is the level can be continued with continuing functionality. This is sent to the backend's send level trace.
		 */

		public function dealWithEndingLevelStuff(type:String):void
		{
			visibilityManager.handleEndOfLevel();
			if (this.currentStory.istutorial)
			{
				tutorial.stopTutorialAndContinueLevel(null,true);
			}
			if (this.currentStory.isQuickPlay) {
				visibilityManager.quickPlayEndingTextHasBeenRendered = false;
				//visibilityManager.quickPlayLevelTextHasBeenRendered = false;
				this.hudGroup.quickPlayInstructionsText.visible = false;
				this.hudGroup.quickPlayHintGroup.visible = false;
			}
			
			
			//this.hudGroup.topBar.visible = false;
			this.hudGroup.megaUI.visible = false;
			this.hudGroup.postSGSFDBEntry.visible = false;
			this.hudGroup.optionsButton.visible = false;
			this.hudGroup.skipLevelOptionMenu.visible = false;
			this.hudGroup.skipToEndOfPromNight.visible = false;
			//this.hudGroup.levelClock.visible = false;
			this.hudGroup.updatesGroup.visible = false;
			this.hudGroup.bugReporterComponent.visible = false;
			this.hudGroup.ssuVisualizer.visible = false;
			this.hudGroup.initiatorDiablogueBubble.visible = false;
			this.hudGroup.responderDiablogueBubble.visible = false;
			this.hudGroup.otherDialogueBubble.visible = false;
			
			if (this.useEndingButtons)
			{
				this.hudGroup.endingWindow.visible = false;
			}
			//hudGroup.goToEndingButton.visible = false;
			this.hudGroup.socialGameButtonRing.visible = false;
			if (this.useJuicePoints)
			{
				this.hudGroup.juiceBar.visible = false;
			}
			
			//this.hudGroup.promTimeClock.visible = false;
			
			this.hudGroup.levelResultsScreen.visible = false;
			if (hudGroup.postSGSFDBEntry)
			{
				try {
				this.hudGroup.removeElement(hudGroup.postSGSFDBEntry);
				}catch (e:ArgumentError) {
					Debug.debug(this, "onCurrentStateChange() ArgumentError on removing the postSGSFDBEntry from hudGroup. error: " + e);
				}
			}
			
			this.hudGroup.autonomousActionGroup.removeAllElements();
			this.hudGroup.autonomousIcons = new Dictionary();
			
			//if you are in this state, we should make sure to not have any change icons going anymore
			for each (var networkChangeIcon:NetworkChangeIcon in this.hudGroup.networkChangeIcons)
			{
				this.hudGroup.removeElement(networkChangeIcon);
			}
			this.hudGroup.networkChangeIcons = new Vector.<NetworkChangeIcon>();
			for each (var statusChangeIcon:StatusChangeIcon in this.hudGroup.statusChangeIcons)
			{
				this.hudGroup.removeElement(statusChangeIcon);
			}
			this.hudGroup.statusChangeIcons = new Vector.<StatusChangeIcon>();
			for each (var relationshipChangeIcon:NetworkChangeIcon in this.hudGroup.relationshipChangeIcons)
			{
				this.hudGroup.removeElement(relationshipChangeIcon);
			}
			this.hudGroup.relationshipChangeIcons = new Vector.<RelationshipChangeIcon>();
			
			var continuable:Boolean = false;
			if (type == "exit" || type == "endOfLevel" || type == "freeplay")
				continuable = true;
			
			var storyName:String = (this.currentStory)?this.currentStory.storyLeadCharacter:"";
			
			if (this.currentLevel.isSandbox) {
				storyName = "freeplay";
			}
			else if (this.currentStory.isQuickPlay) {
				storyName = currentStory.title; // should be something like "QP1" or whatever.
			}
			
			//locally store the trace
			if (continuable) {
				if (this.currentLevel.isSandbox) {
					this.freeplayLevelTraceXML = this.backend.generateLevelTraceXML(this.cif.sfdb, this.levelStartedTime, cif.time, this.currentLevel.title, storyName, type);
					this.getFreeplayLevelTrace = false;
				}else {
					this.continueLevelTraceXML = this.backend.generateLevelTraceXML(this.cif.sfdb, this.levelStartedTime, cif.time, this.currentLevel.title, storyName, type);
					this.getContinueLevelTrace = false;
				}
			}
			this.backend.sendLevelTrace(this.cif.sfdb, this.levelStartedTime, cif.time, this.currentLevel.title, storyName, continuable, type);
			
		
			this.hudGroup.storyGoalWindow.toDoItemAccordion.updateToDoList();
			
			
			/*if (this.currentLevel.evaluateGoals())
			{
				this.hudGroup.levelResultsScreen.youLoseText.visible = false;
				this.hudGroup.levelResultsScreen.youWonText.visible = true;
			}
			else
			{
				this.hudGroup.levelResultsScreen.youLoseText.visible = true;
				this.hudGroup.levelResultsScreen.youWonText.visible = false;
			}*/
			if("endOfLevel" == type) {
				statisticsManager.endOfLevelHandler(); //
				this.hudGroup.levelResultsScreen.updateLevelResultsScreen();
			}
			if ("freeplay" == type) {
				//Clear out the selected story lead character for when you return to the "normal" character select screen.
				Debug.debug(this, "I'm getting here I think yes yes yes of course!");
				currentStory = this.stories[0];
				hudGroup.storySelectionScreen.changeStoryDescription(this.stories[0].title, this.stories[0].description);
				hudGroup.storySelectionScreen.changeAvatar(this.stories[0].storyLeadCharacter);
				hudGroup.storySelectionScreen.selectedStory = this.stories[0];		
			}
			
			
			
			this.socialGameContext = null;
			this.socialGamePlaying = false;
		}
		
		/**
		 * Used to find the most salient story tidbit to display on the level objective screen
		 * TODO: Make this work with locutions, to do this we will need to know who the conidtion evaluated true for
		 * 
		 * 
		 * @return
		 */
		public function getStoryTidBit():String
		{
			var tb:TidBit
			var chosenTidBit:TidBit;
			var possibleTidBits:Vector.<TidBit> = new Vector.<TidBit>();
			for each (var toDoItem:ToDoItem in this.currentStory.todoList)
			{
				if (chosenTidBit != null) break;
				
				if (toDoItem.evaluateCondition())
				{
					for each (tb in toDoItem.tidbits)
					{
						if (!tb.hasBeenSeen)
						{
							//possibleTidBits.push(tb);
							chosenTidBit = tb;
							break;
						}
					}
				}
			}
			
			if (chosenTidBit != null)
			{
				chosenTidBit.hasBeenSeen = true;
				return chosenTidBit.originalTemplateString;
			}
			return "";
			/*
			for each (tb in possibleTidBits)
			{
				if (!tb.hasBeenSeen)
				{
					chosenTidBit = tb;
				}
			}
			if (chosenTidBit == null && possibleTidBits.length > 0)
			{
				chosenTidBit = possibleTidBits[Util.randRange(0,possibleTidBits.length-1)];
			}
			
			if (chosenTidBit != null)
			{
				chosenTidBit.renderText(
			}*/
		}
		
		
		public function sfdbEntryClickedOn(e:MouseEvent = null):void
		{
			if (!this.isFormingIntent)
			{
				hudGroup.postSGSFDBEntry.visible = false;
			}
		}
		
		public function setInitiatorInfluenceRuleVector(sg:SocialGame, initiator2:Character, responder2:Character, other2:Character = null):void
		{
			this.latestInitiatorInfluenceRules = new Vector.<String>();
			
			var theory:Microtheory;
			var i:int;
						
			for each (theory in cif.microtheories)
			{
				if (theory.definition.evaluate(initiator2, responder2, other2, sg)) 
				{
					for (i = 0; i < theory.initiatorIRS.influenceRules.length; i++)
					{
						if (theory.initiatorIRS.influenceRules[i].weight != 0)
						{
							if (theory.initiatorIRS.influenceRules[i].evaluate(initiator2,responder2,other2,sg))
							{
								latestInitiatorInfluenceRules.push(theory.initiatorIRS.influenceRules[i].weight + " MT: " + theory.name + ": " + theory.initiatorIRS.influenceRules[i].generateRuleName())
							}
						}
					}
				}
			}
			for (i = 0; i < sg.initiatorIRS.influenceRules.length; i++)
			{
				if (sg.initiatorIRS.influenceRules[i].weight != 0)
				{
					if (sg.initiatorIRS.influenceRules[i].evaluate(initiator2,responder2,other2,sg))
					{
						latestInitiatorInfluenceRules.push(sg.initiatorIRS.influenceRules[i].weight + " SG: " + sg.name + ": " + sg.initiatorIRS.influenceRules[i].generateRuleName())
					}
				}
			}
		}
			
			
		public function setResponderInfluenceRuleVector(sg:SocialGame, initiator2:Character, responder2:Character, other2:Character = null):void
		{
			this.latestResponderInfluenceRules = new Vector.<String>();
			
			var theory:Microtheory;
			var i:int;
			
			for each (theory in cif.microtheories)
			{
				for (i = 0; i < theory.responderIRS.influenceRules.length; i++)
				{
					if (theory.definition.evaluate(responder2,initiator2, other2, sg)) 
					{
						if (theory.responderIRS.influenceRules[i].weight != 0)
						{
							if (theory.responderIRS.influenceRules[i].evaluate(responder2, initiator2,other2,sg))
							{
								latestResponderInfluenceRules.push(theory.responderIRS.influenceRules[i].weight + " MT: " + theory.name + ": " + theory.responderIRS.influenceRules[i].generateRuleName())
							}
						}
					}
				}
			}
			for (i = 0; i < sg.responderIRS.influenceRules.length; i++)
			{
				if (sg.responderIRS.influenceRules[i].weight != 0)
				{
					if (sg.responderIRS.influenceRules[i].evaluate(initiator2,responder2,other2,sg))
					{
						latestResponderInfluenceRules.push(sg.responderIRS.influenceRules[i].weight + " SG: " + sg.name + ": " + sg.responderIRS.influenceRules[i].generateRuleName())
					}
				}
			}
		}
		
		
		/**
		 * Proceed to the next level
		 * @param	event The standard mouse event associated with click handlers
		 */
		public function onClickInEndOfLevelResultState(event:MouseEvent=null):void {
			//trace ("clicked in End Of Level Result State!  Time to start the next level!");		
			
			
			this.currentState = "LoadingLevel";
			
		}
		
		
		/**
		 * Used to track mouse clicking on the Level Objective screen.
		 * For starters, have it click anywhere and then it will just take you to the next screen!
		 * @param	event The standard mouse event associated with click handlers
		 */
		public function onClickInLevelObjectiveState(event:MouseEvent = null ):void {

			//if (this.firstIntentHasBeenFormed)
			//{
				gentleFadeFlag = true; // start gently fading the objective screen out
				this.currentState = "Interaction"; //and start interaction mode of gameplay!
				
				//this.hudGroup.topBar.visible = true;
				//this.hudGroup.levelClock.visible = true;
				this.hudGroup.megaUI.visible = true;
				if (visibilityManager.useOldInterface)
				{
					this.hudGroup.optionsButton.visible = true;
				}
				this.hudGroup.updatesGroup.visible = true;
				
				//this.hudGroup.megaUI.clear();
				if (this.hudGroup.megaUI.megaUIExpanded)
				{
					this.hudGroup.megaUI.setToMiniMap();
				}
				this.hudGroup.megaUI.setButtonsToAppropriateEnabledState();
				
				this.hudGroup.stuffToGoOnTopGroup.visible = true;
				
				if (currentLevel.endable)// && this.hudGroup.endingWindow.atleastOneEnding) 
				{
					//this.currentStory.evaluateEndingPreconditions(currentLevel.cast)
					if (this.useEndingButtons)
					{
						this.currentStory.evaluateEndingPreconditions(cif.cast.characters);
						this.hudGroup.endingWindow.visible = true;
					}
					//hudGroup.goToEndingButton.visible = true;
					//this.hudGroup.topBar.goToLevelButton.enabled = false;
				}
				else
				{
					//this.hudGroup.topBar.goToLevelButton.enabled = true;
				}
				
				
				if (visibilityManager.useOldInterface)
				{
					if (this.useJuicePoints)
					{
						this.hudGroup.juiceBar.visible = true;
					}
				}
				this.hudGroup.storyGoalWindow.toDoItemAccordion.updateToDoList();
			//}
		}

		public function onClickInPerformanceState(event:MouseEvent = null):void {
			//Debug.debug(this, "onClickInPerformanceState()");
					

			
			//Maybe handle the 'click to continue' timer  here?
			this.hudGroup.clickToContinueText.visible = false; // turn off the old one
			//this.hudGroup.clickToContinueText.visible = true; // turn on the new one (after time has passed)
			currentLineOfDialogueStartTime = new Date().time;
			//Debug.debug(this, "currentLineOfDialogueStartTime after click: " + currentLineOfDialogueStartTime);
			
			//don't let them click if the other is still walking on stage (otherwise you might accidentally skip the other's lines.
			if (this.dialougeLineNumber > 0)
			{
				if (this.currentDialogueInstantiation.lines[this.dialougeLineNumber - 1].otherApproach) {
					if (this.otherArrived) {
						//Proceed as normal
						Debug.debug(this, "proceeding as normal!");
						this.hudGroup.otherIsApproachingText.visible = false; // in case it was visible.
					}
					else {
						//They haven't gotten there yet!  Dont let them click ahead!
						Debug.debug(this, "don't let them click ahead!");
						this.hudGroup.otherIsApproachingText.visible = true;
						return;
					}
				}
			}
			
			//if there was a partial change, display the state change information instead of showing the next line
			if (this.dialougeLineNumber > 0 
				&& this.dialougeLineNumber <= this.currentDialogueInstantiation.lines.length
				&& !this.currentLoDPartialChangeDealtWithYet[this.dialougeLineNumber - 1]
				&& this.currentDialogueInstantiation.lines[this.dialougeLineNumber - 1].partialChange.predicates.length > 0)
			{
				//visualize each predicate's change
				for each (var pred:Predicate in currentDialogueInstantiation.lines[this.dialougeLineNumber - 1].partialChange.predicates)
				{
					//Debug.debug(this,"Resp: "+this.responderName+"Init: "+this.initiatorName);
					visualizeSocialChange(pred, this.initiatorName, this.responderName, otherName);
				}
				//need to say we're done visualizing somehow
				//need to say we're done visualizing somehow
				this.currentLoDPartialChangeDealtWithYet[this.dialougeLineNumber - 1] = true;
			}
			else
			{
				//clear the previous social state change visualizations
				for each (var relChange:RelationshipChangeIcon in this.hudGroup.relationshipChangeIcons)
				{
					this.hudGroup.removeElement(relChange);
				}
				this.hudGroup.relationshipChangeIcons = new Vector.<RelationshipChangeIcon>();		
				for each (var netChange:NetworkChangeIcon in this.hudGroup.networkChangeIcons)
				{
					this.hudGroup.removeElement(netChange);
				}
				this.hudGroup.networkChangeIcons = new Vector.<NetworkChangeIcon>();
				for each (var statusChange:StatusChangeIcon in this.hudGroup.statusChangeIcons)
				{
					this.hudGroup.removeElement(statusChange);
				}
				this.hudGroup.statusChangeIcons = new Vector.<StatusChangeIcon>();
			
				//update the performance as usual
				updatePerformance();
			}
		}

		
		public function isPresentInLevel(name:String):Boolean
		{
			for each (var char:Character in this.currentLevel.cast)
			{
				if (char.characterName == name )
				{
					return true;
				}
			}
			return false;
		}
		
		public function visualizeSocialChange(pred:Predicate, initName:String, respName:String, otherName:String=null,subjectiveOpinionNoNumber:Boolean=false):void
		{
			var toWho:String = "";
			var fromWho:String = "";
			if (pred.primary == "initiator")
			{
				fromWho = initName;
				if (pred.secondary == "responder")
				{
					toWho = respName;
				}
				else if (pred.secondary == "other")
				{
					toWho = otherName;
				}
			}
			else if (pred.primary == "responder") 
			{
				fromWho = respName;
				if (pred.secondary == "initiator")
				{
					toWho = initName;
				}
				else if (pred.secondary == "other")
				{
					toWho = otherName;
				}
			}
			else if (pred.primary == "other")
			{
				//Debug.debug(this,"visualizeSocialChange() Entered pred.primary==other");
				fromWho = otherName;// cif.sfdb.getLatestSocialGameContext().getOther().characterName;
				if (pred.secondary == "initiator")
				{
					toWho = initName;
				}
				else if (pred.secondary == "responder")
				{
					toWho = respName;
				}
			}
			else
			{
				//this means that we are visualizing a trigger-like thing with the actual character names
				fromWho = initName;
				toWho = respName;
			}
			
			Debug.debug(this,"visualizeSocialChange() From Who: " + fromWho + " toWho: " + toWho + " pred: " + pred );
			
			if (pred.type == Predicate.NETWORK)
			{
				var netChangeVis:NetworkChangeIcon = new NetworkChangeIcon(fromWho, toWho, SocialNetwork.getNameFromType(pred.networkType), pred.networkValue, pred.operator,subjectiveOpinionNoNumber);
				hudGroup.networkChangeIcons.push(netChangeVis);
				hudGroup.addElement(netChangeVis);
				//Debug.debug(this, "VisualizeSocialChange() playing network sound for pred: " + pred.toString());
				playNetworkChangeSound(pred.networkType, pred.networkValue, pred.operator);
			}
			else if (pred.type == Predicate.RELATIONSHIP)
			{
				var relChangeVis:RelationshipChangeIcon = new RelationshipChangeIcon(fromWho, toWho,RelationshipNetwork.getRelationshipNameByNumber(pred.relationship), pred.negated);
				hudGroup.relationshipChangeIcons.push(relChangeVis);
				hudGroup.addElement(relChangeVis);
				
				playRelationshipChangeSound(pred.relationship, pred.negated);
			}
			else if (pred.type == Predicate.STATUS)
			{
				var statusChangeVis:StatusChangeIcon = new StatusChangeIcon();// fromWho, toWho, pred.status);
				statusChangeVis.fromWho = fromWho;
				statusChangeVis.toWho = toWho;
				statusChangeVis.negated = pred.negated;
				statusChangeVis.status = pred.status;
				statusChangeVis.statusIcon.shouldDisplayName = true;
				statusChangeVis.statusIcon.shouldDisplayTimeRemaining = false;
				statusChangeVis.initializeStatusIcon()
				hudGroup.statusChangeIcons.push(statusChangeVis);
				hudGroup.addElement(statusChangeVis);
			}
		}
		
		public function playTheGame(gameName:String):void
		{					
			this.currentlySelectedSG = gameName;
			this.currentlySelectedInitiator = this.primaryAvatarSelection;
			this.currentlySelectedResponder = this.secondaryAvatarSelection;
			
			//also, populate the megaUI! This is pretty ugly bad, but what evs
			this.hudGroup.megaUI.sgInfo.loadSGInfo(gameName);
			
			this.socialGameToPerform = gameName;
			
			this.initiatorName = this.primaryAvatarSelection;
			this.responderName = this.secondaryAvatarSelection;
			
			this.worldGroup.avatars[this.initiatorName].lookingAtTarget = this.responderName.toLowerCase();
			this.worldGroup.avatars[this.responderName].lookingAtTarget = this.initiatorName.toLowerCase();
			
			this.hudGroup.updatesGroup.visible = false;
			
			this.currentState = "Performance";
		}
		
		public function playRelationshipChangeSound(relationshipType:Number, negated:Boolean):void
		{
			var sound:Sound;
			
			if (relationshipType == RelationshipNetwork.FRIENDS)
			{
				if (!negated)
				{
					//becoming friends
					sound = new soundLibrary.socialStateSounds["friends_begin"]() as Sound;
					if(this.isSoundOn) soundChannel = sound.play(0,0,this.soundFXTransform);
				}
				else
				{
					//stopping being friends
					sound = new soundLibrary.socialStateSounds["friends_end"]() as Sound;
					if(this.isSoundOn) soundChannel = sound.play(0,0,this.soundFXTransform)
				}
			}
			else if (relationshipType == RelationshipNetwork.DATING)
			{
				if (!negated)
				{
					sound = new soundLibrary.socialStateSounds["dating_begin"]() as Sound;
					if(this.isSoundOn) soundChannel = sound.play(0,0,this.soundFXTransform)
				}
				else
				{
					sound = new soundLibrary.socialStateSounds["dating_end"]() as Sound;
					if(this.isSoundOn) soundChannel = sound.play(0,0,this.soundFXTransform)
				}
			}
			else if (relationshipType == RelationshipNetwork.ENEMIES)
			{
				if (!negated)
				{
					sound = new soundLibrary.socialStateSounds["enemies_begin"]() as Sound;
					if(this.isSoundOn) soundChannel = sound.play(0,0,this.soundFXTransform)
				}
				else
				{
					sound = new soundLibrary.socialStateSounds["enemies_end"]() as Sound;
					if(this.isSoundOn) soundChannel = sound.play(0,0,this.soundFXTransform)
				}
			}
		}
		
		
		public function playNetworkChangeSound(networkType:Number, networkValue:Number, networkOperator:String):void
		{	
			var sound:Sound;
			if (networkType == SocialNetwork.BUDDY)
			{
				if (networkOperator == "+")
				{
					//play buddy up
					sound = new soundLibrary.socialStateSounds["buddy_up"]() as Sound;
					if(this.isSoundOn) soundChannel = sound.play(0,0,this.soundFXTransform)
				}
				else if (networkOperator == "-")
				{
					sound = new soundLibrary.socialStateSounds["buddy_down"]() as Sound;
					if(this.isSoundOn) soundChannel = sound.play(0,0,this.soundFXTransform)
				}
			}
			else if (networkType == SocialNetwork.ROMANCE)
			{
				if (networkOperator == "+")
				{
					sound = new soundLibrary.socialStateSounds["romance_up"]() as Sound;
					if(this.isSoundOn) soundChannel = sound.play(0,0,this.soundFXTransform)
				}
				else if (networkOperator == "-")
				{
					sound = new soundLibrary.socialStateSounds["romance_down"]() as Sound;
					if(this.isSoundOn) soundChannel = sound.play(0,0,this.soundFXTransform)
				}
			}
			else if (networkType == SocialNetwork.COOL)
			{
				if (networkOperator == "+")
				{
					sound = new soundLibrary.socialStateSounds["cool_up"]() as Sound;
					if(this.isSoundOn) soundChannel = sound.play(0,0,this.soundFXTransform)
				}
				else if (networkOperator == "-")
				{
					sound = new soundLibrary.socialStateSounds["cool_down"]() as Sound;
					if(this.isSoundOn) soundChannel = sound.play(0,0,this.soundFXTransform)
				}
			}
		}
		
		/**
		 * This function will use the freshly created intents to get the new subjective opinions. This is for
		 * use with the subjective opinion lines in the char info ui and the prev ones are for use in displaying
		 * changes in line length. Handled else where (the place where trigger changes are visualized)
		 */
		public function updatePresentCharacterSubjectiveOpinions():void
		{
			var charTo:Character;
			var charFrom:Character;
			for each (charTo in this.currentLevel.cast)
			{
				for each (charFrom in this.currentLevel.cast)
				{
					this.worldGroup.avatars[charTo.characterName.toLowerCase()].prevSubjectiveGreenOpinions[charFrom.networkID] = this.worldGroup.avatars[charTo.characterName.toLowerCase()].subjectiveGreenOpinions[charFrom.networkID];
					this.worldGroup.avatars[charTo.characterName.toLowerCase()].subjectiveGreenOpinions[charFrom.networkID] = this.worldGroup.avatars[charTo.characterName.toLowerCase()].createGreenValueTowards(charFrom);
					
					this.worldGroup.avatars[charTo.characterName.toLowerCase()].prevSubjectiveRedOpinions[charFrom.networkID] = this.worldGroup.avatars[charTo.characterName.toLowerCase()].subjectiveRedOpinions[charFrom.networkID];
					this.worldGroup.avatars[charTo.characterName.toLowerCase()].subjectiveRedOpinions[charFrom.networkID] = this.worldGroup.avatars[charTo.characterName.toLowerCase()].createRedValueTowards(charFrom);
					
					this.worldGroup.avatars[charTo.characterName.toLowerCase()].prevSubjectiveBlueOpinions[charFrom.networkID] = this.worldGroup.avatars[charTo.characterName.toLowerCase()].subjectiveBlueOpinions[charFrom.networkID];
					this.worldGroup.avatars[charTo.characterName.toLowerCase()].subjectiveBlueOpinions[charFrom.networkID] = this.worldGroup.avatars[charTo.characterName.toLowerCase()].createBlueValueTowards(charFrom);
				}
			}
		}
		/**
		 * This function will queue network change predicates in the predicates to display vector that is used to display status change animations
		 * This should be called only after updatePresentCharacterSubjectiveOpinions has been called
		 */
		public function queueSubjectiveOpinionChangeAnimations():void
		{
			var charTo:Character;
			var charFrom:Character;
			var pred:Predicate;
			
			for each (charTo in this.currentLevel.cast)
			{
				for each (charFrom in this.currentLevel.cast)
				{
					if (charTo.characterName != charFrom.characterName)
					{
						if (this.worldGroup.avatars[charTo.characterName.toLowerCase()].subjectiveGreenOpinions[charFrom.networkID] != Avatar.DEFAULT_SUBJECTIVE_OPINION && this.worldGroup.avatars[charTo.characterName.toLowerCase()].prevSubjectiveGreenOpinions[charFrom.networkID] != Avatar.DEFAULT_SUBJECTIVE_OPINION)
						{
							var greenChange:Number = this.worldGroup.avatars[charTo.characterName.toLowerCase()].subjectiveGreenOpinions[charFrom.networkID] - this.worldGroup.avatars[charTo.characterName.toLowerCase()].prevSubjectiveGreenOpinions[charFrom.networkID];
							if (Math.abs(greenChange) > GameEngine.MIN_SUBJECTIVE_OPINION_CHANGE_FOR_ANIMATION)
							{
								pred = new Predicate();
								pred.type = Predicate.NETWORK;
								pred.networkType = SocialNetwork.BUDDY;
								pred.primary = charTo.characterName;
								pred.secondary = charFrom.characterName;
								pred.networkValue = Math.abs(Math.round(greenChange*100));
								//this means we do in fact want to play an animation for subjective opinion Change
								if (greenChange > 0)
								{
									//Debug.debug(this, "queueSubjectiveOpinionChangeAnimations() " + charTo.characterName + "'s green toward " + charFrom.characterName + " went up by: " + greenChange);
									//this.outputWhatRulesChangedByType("greenPos",charTo,charFrom);
									pred.operator = "+";
								}
								else
								{
									//Debug.debug(this, "queueSubjectiveOpinionChangeAnimations() " + charTo.characterName + "'s green toward " + charFrom.characterName + " went down by: " + greenChange);
									//this.outputWhatRulesChangedByType("greenNeg",charTo,charFrom);
									pred.operator = "-";
								}
								this.hudGroup.toDisplaySubjectiveChangeAnimations.push(pred);
							}
						}
						if (this.worldGroup.avatars[charTo.characterName.toLowerCase()].subjectiveRedOpinions[charFrom.networkID] != Avatar.DEFAULT_SUBJECTIVE_OPINION && this.worldGroup.avatars[charTo.characterName.toLowerCase()].prevSubjectiveRedOpinions[charFrom.networkID] != Avatar.DEFAULT_SUBJECTIVE_OPINION)
						{
							var redChange:Number = this.worldGroup.avatars[charTo.characterName.toLowerCase()].subjectiveRedOpinions[charFrom.networkID] - this.worldGroup.avatars[charTo.characterName.toLowerCase()].prevSubjectiveRedOpinions[charFrom.networkID];
							if (Math.abs(redChange) > GameEngine.MIN_SUBJECTIVE_OPINION_CHANGE_FOR_ANIMATION)
							{
								pred = new Predicate();
								pred.type = Predicate.NETWORK;
								pred.networkType = SocialNetwork.ROMANCE;
								pred.primary = charTo.characterName;
								pred.secondary = charFrom.characterName;
								pred.networkValue = Math.abs(Math.round(redChange*100));
								//this means we do in fact want to play an animation for subjective opinion Change
								if (redChange > 0)
								{
									//Debug.debug(this, "queueSubjectiveOpinionChangeAnimations() " + charTo.characterName + "'s red toward " + charFrom.characterName + " went up by: " + redChange);
									//this.outputWhatRulesChangedByType("redPos",charTo,charFrom);
									pred.operator = "+";
								}
								else
								{
									//Debug.debug(this, "queueSubjectiveOpinionChangeAnimations() " + charTo.characterName + "'s red toward " + charFrom.characterName + " went down by: " + redChange);
									//this.outputWhatRulesChangedByType("redNeg",charTo,charFrom);
									pred.operator = "-";
								}
								this.hudGroup.toDisplaySubjectiveChangeAnimations.push(pred);
							}
						}
						if (this.worldGroup.avatars[charTo.characterName.toLowerCase()].subjectiveBlueOpinions[charFrom.networkID] != Avatar.DEFAULT_SUBJECTIVE_OPINION && this.worldGroup.avatars[charTo.characterName.toLowerCase()].prevSubjectiveBlueOpinions[charFrom.networkID] != Avatar.DEFAULT_SUBJECTIVE_OPINION)
						{
							var blueChange:Number = this.worldGroup.avatars[charTo.characterName.toLowerCase()].subjectiveBlueOpinions[charFrom.networkID] - this.worldGroup.avatars[charTo.characterName.toLowerCase()].prevSubjectiveBlueOpinions[charFrom.networkID];
							if (Math.abs(blueChange) > GameEngine.MIN_SUBJECTIVE_OPINION_CHANGE_FOR_ANIMATION)
							{
								pred = new Predicate();
								pred.type = Predicate.NETWORK;
								pred.networkType = SocialNetwork.COOL;
								pred.primary = charTo.characterName;
								pred.secondary = charFrom.characterName;
								pred.networkValue = Math.abs(Math.round(blueChange*100));
								//this means we do in fact want to play an animation for subjective opinion Change
								if (blueChange > 0)
								{
									//Debug.debug(this, "queueSubjectiveOpinionChangeAnimations() " + charTo.characterName + "'s blue toward " + charFrom.characterName + " went up by: " + blueChange);
									//this.outputWhatRulesChangedByType("bluePos",charTo,charFrom);
									pred.operator = "+";
								}
								else
								{
									//Debug.debug(this, "queueSubjectiveOpinionChangeAnimations() " + charTo.characterName + "'s blue toward " + charFrom.characterName + " went down by: " + blueChange);
									//this.outputWhatRulesChangedByType("blueNeg",charTo,charFrom);
									pred.operator = "-";
								}
								this.hudGroup.toDisplaySubjectiveChangeAnimations.push(pred);
							}
						}
					}
				}
			}
			
			
			// sort the changes we found and take only the top three
			function comp(x:Predicate, y:Predicate):Number 
			{
				if (x.networkValue < y.networkValue)
				{
					return 1.0;
				}
				else if (x.networkValue > y.networkValue)
				{
					return -1.0;
				}
				else
				{
					return 0;
				}
			}
			this.hudGroup.toDisplaySubjectiveChangeAnimations.sort(comp);
			
			
			var subToDisplay:Vector.<Predicate> = new Vector.<Predicate>();
			for (var j:int = 0; j < 3; j++ )
			{
				if (j < this.hudGroup.toDisplaySubjectiveChangeAnimations.length)
				{
					subToDisplay.push(this.hudGroup.toDisplaySubjectiveChangeAnimations[j]);
				}
			}
			this.hudGroup.toDisplaySubjectiveChangeAnimations = subToDisplay;
		}
		
		/**
		 * This outputs all rules that changed between cif.time and cif.time-1 for chars
		 * 
		 * @param	type - either greenPos greenNeg redPos redNeg bluePos blueNeg
		 */
		/*
		public function outputWhatRulesChangedByType(type:String, charFrom:Character, charTo:Character):void
		{
			var lastTurnTrue:Boolean;
			var thisTurnTrue:Boolean;
			var other:Character;
			var intentIndex:int;
			for (var ir:InfluenceRule in CiF.InstrumentedInfluenceRule.rulesByID) 
			{
				intentIndex = ir.findIntentIndex();
				if (ir.requiresThirdCharacter())
				{
					for each (other in this.currentLevel.cast)
					{
						thisTurnTrue = ir.history[cif.time][charFrom.characterName][charTo.characterName][other.characterName]["result"] as Boolean
						lastTurnTrue = ir.history[cif.time-1][charFrom.characterName][charTo.characterName][other.characterName]["result"] as Boolean
						
						//nothing changed, and it was always true
						//if (lastTurnTrue && thisTurnTrue) 
						//always false
						//if(!lastTurnTrue && !thisTurnTrue)
						//became true
						if (!lastTurnTrue && thisTurnTrue)
						{
							
						}
						//became false
						if (lastTurnTrue && !thisTurnTrue)
						{
							
						}
					}
				}
				else
				{
					thisTurnTrue = ir.history[cif.time][charFrom.characterName][charTo.characterName]["none"]["result"] as Boolean
					lastTurnTrue = ir.history[cif.time-1][charFrom.characterName][charTo.characterName]["none"]["result"] as Boolean
					
					//nothing changed, and it was always true
					//if (lastTurnTrue && thisTurnTrue) 
					//always false
					//if(!lastTurnTrue && !thisTurnTrue)
					//became true
					if (!lastTurnTrue && thisTurnTrue)
					{
						
					}
					//became false
					if (lastTurnTrue && !thisTurnTrue)
					{
						
					}
				}
			}
		}
		*/
		public function onClickInResultsState(event:MouseEvent=null):void 
		{
			if (!this.isFormingIntent)
			{			
				this.updatePresentCharacterSubjectiveOpinions();
				//this.queueSubjectiveOpinionChangeAnimations();
				
				if (useBetweenTurnHints)
				{
					this.hudGroup.betweenTurnHint.visible = false;
				}
				
				hudGroup.socialGameResultsUI.visible = false;

				hudGroup.initiatorDiablogueBubble.visible = false;
				hudGroup.responderDiablogueBubble.visible = false;
				
				this.hudGroup.stuffToGoOnTopGroup.visible = true;
				
				worldGroup.avatars[initiatorName].moveToLocation(worldGroup.avatars[initiatorName].homeLocX, worldGroup.avatars[initiatorName].homeLocY);
				worldGroup.avatars[initiatorName].lookingAtTarget = worldGroup.avatars[initiatorName].homeTargetLookingDirection;

				worldGroup.avatars[responderName].moveToLocation(worldGroup.avatars[responderName].homeLocX, worldGroup.avatars[responderName].homeLocY);
				worldGroup.avatars[responderName].lookingAtTarget = worldGroup.avatars[responderName].homeTargetLookingDirection;
				
				if(worldGroup.avatars[otherName.toLowerCase()]){ // if other performed, now they will move home too.
					worldGroup.avatars[otherName.toLowerCase()].moveToLocation(worldGroup.avatars[otherName.toLowerCase()].homeLocX, worldGroup.avatars[otherName.toLowerCase()].homeLocY);
					worldGroup.avatars[otherName.toLowerCase()].lookingAtTarget = worldGroup.avatars[otherName.toLowerCase()].homeTargetLookingDirection;
				}
				
				//Zoom the camera back out to what it was before a social game was played.
				this.camera.zoom = this.camera.previousZoom;
				this.camera.update();
				//this.hudGroup.megaUI.clear();
				if(this.hudGroup.megaUI.megaUIExpanded)
				{
					this.hudGroup.megaUI.setToMiniMap();
				}
				
				this.hudGroup.megaUI.visible = true;
				if (visibilityManager.useOldInterface)
				{
					this.hudGroup.optionsButton.visible = true;
				}
				else
				{
					this.hudGroup.topBar.visible = true;
				}
				this.hudGroup.updatesGroup.visible = true;
				if (visibilityManager.useQuickPlayLevelInstructions) this.hudGroup.quickPlayLevelInstructionsLabel.visible = true; // quick play feature
				if (visibilityManager.useResetStateButton) this.hudGroup.resetStateButton.visible = true; // quick play feature.
				
				this.lengthOfSocialExchangePerformance = new Date().time - this.startOfSocialExchangePerformance;
				//update everyone's next ssu time
				for each (var charForSSU:Character in cif.cast.characters)
				{
					//sometimes don't do this
					if (Math.random() < 0.7)
					{
						this.timeTillNextSocialStatusUpdate[charForSSU.characterName] += this.lengthOfSocialExchangePerformance;
					}
				}
				
				this.currentState = "Interaction";
			}
		}
		
		public function updatePerformance():void
		{
			if (socialGamePlaying)		//socialGamePlaying is set when all of the characters are in location
			{
				if (soundChannel)
				{
					soundChannel.stop();
				}
				
				//if there are more lines of dialog
				if (dialougeLineNumber < currentDialogueInstantiation.lines.length)
				{
					
					
					hudGroup.initiatorDiablogueBubble.visible = false;
					hudGroup.responderDiablogueBubble.visible = false;
					
					//hudGroup.initiatorDiablogueBubble.update(initiatorName);
					//hudGroup.responderDiablogueBubble.update(responderName);
					
					var line:LineOfDialogue = currentDialogueInstantiation.lines[dialougeLineNumber];
					
					//Debug.debug(this, "Line: " + line.toString() );
					
					if (line.initiatorLine != "")
					{
						//hudGroup.initiatorDiablogueBubble.pointRight = true;
						hudGroup.initiatorDiablogueBubble.thought = line.initiatorIsThought;
						hudGroup.initiatorDiablogueBubble.text = LineOfDialogue.preprocessLine(line.initiatorLine);
						hudGroup.initiatorDiablogueBubble.updateLocation();
						
						
						
						
						hudGroup.initiatorDiablogueBubble.visible = true;
					}
					else
					{
						hudGroup.initiatorDiablogueBubble.visible = false;
					}
					
					if (line.initiatorBodyAnimation != null && line.initiatorBodyAnimation != "" && line.initiatorBodyAnimation != "null" && line.initiatorBodyAnimation != "no action")
					{
						worldGroup.avatars[initiatorName].clip.gotoAndPlay(line.initiatorBodyAnimation);
					}
					
					if (line.initiatorFaceState != "")
					{
						if (line.initiatorFaceState == "very happy")
						{
							line.initiatorFaceState = "happy"
						}
						if (line.initiatorFaceState == "very sad")
						{
							line.initiatorFaceState = "sad"
						}
						worldGroup.avatars[initiatorName].clip.faceMC.currentState = line.initiatorFaceState;
					}
					
					if (line.initiatorFaceAnimation != null && line.initiatorFaceAnimation != "null"&& line.initiatorFaceAnimation != "no action" && line.initiatorFaceAnimation != "")
					{
						//Debug.debug(this, "updatePerformance() Setting faceAnim to " + line.initiatorFaceAnimation);
						//worldGroup.avatars[initiatorName].clip.faceMC.playAnim(line.initiatorFaceAnimation);
						worldGroup.avatars[initiatorName].clip.faceMC.playAnim(line.initiatorFaceAnimation);
					}
					else
					{
						//Debug.debug(this, "updatePerformance() ********* Going to state " + worldGroup.avatars[initiatorName].clip.faceMC.currentState);
						worldGroup.avatars[initiatorName].clip.faceMC.goToState();
					}	
					//Debug.debug(this, "-- INITIATOR --");
					//Debug.debug(this, "updatePerformance() line: \"" + line.initiatorLine + "\"");
					//Debug.debug(this, "updatePerformance() body: " + line.initiatorBodyAnimation);
					//Debug.debug(this, "updatePerformance() faceAnim: " + line.initiatorFaceAnimation);
					//Debug.debug(this, "updatePerformance() faceState: " + line.initiatorFaceState);
					//Debug.debug(this, "updatePerformance() currentState: " + worldGroup.avatars[initiatorName].clip.faceMC.currentState);
					
					
				    //Attempt at tracing emotional utterances for initiator and responder
					//-Do we check face states to know what to play?
					
					
					//soundChannel = (soundLibrary.maleUtterances["happy"] as Sound).play();//1000, 3);
					//var sound:Sound = new soundLibrary.maleUtterances["happy"]() as Sound;
					//sound.play();//1000, 3);
					
					var sound:Sound;// = new Sound;
					
					var initiatorMadeSound:Boolean = false;
					/*
					if (Math.random() < PromWeek.GameEngine.UTTERANCE_FREQUENCY)
					{
						initiatorMadeSound = true;
						
						if (line.initiatorFaceState == "idle") {
							if (cif.cast.getCharByName(initiatorName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["idle"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["idle"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator idle sound should be played");
						}
						if (line.initiatorFaceState == "angry") {
							if (cif.cast.getCharByName(initiatorName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["angry"]() as Sound;
							}
							else 
							{
								sound = new soundLibrary.femaleUtterances["angry"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator angry sound should be played");
						}
						if (line.initiatorFaceState == "anxious") {
							if (cif.cast.getCharByName(initiatorName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["anxious"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["anxious"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator anxious sound should be played");
						}
						if (line.initiatorFaceState == "concerned") {
							if (cif.cast.getCharByName(initiatorName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["concerned"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["concerned"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator concerned sound should be played");
						}
						if (line.initiatorFaceState == "disinterested") {
							if (cif.cast.getCharByName(initiatorName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["disinterested"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["disinterested"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator disinterested sound should be played");
						}
						if (line.initiatorFaceState == "happy") {
							if (cif.cast.getCharByName(initiatorName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["happy"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["happy"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator happy sound should be played");
						}
						if (line.initiatorFaceState == "veryHappy") {
							if (cif.cast.getCharByName(initiatorName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["veryHappy"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["veryHappy"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator very happy sound should be played");
						}
						if (line.initiatorFaceState == "resentful") {
							if (cif.cast.getCharByName(initiatorName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["resentful"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["resentful"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator resentful sound should be played");
						}
						if (line.initiatorFaceState == "sad") {
							if (cif.cast.getCharByName(initiatorName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["sad"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["sad"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator sad sound should be played");
						}
						if (line.initiatorFaceState == "verySad") {
							if (cif.cast.getCharByName(initiatorName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["verySad"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["verySad"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator very sad sound should be played");
						}
					}

					*/

					if (line.responderLine != "")
					{
						//hudGroup.responderDiablogueBubble.pointLeft = true;
						hudGroup.responderDiablogueBubble.thought = line.responderIsThought;
						hudGroup.responderDiablogueBubble.text = LineOfDialogue.preprocessLine(line.responderLine);
						hudGroup.responderDiablogueBubble.updateLocation();
						
						
						hudGroup.responderDiablogueBubble.visible = true;
					}
					else
					{
						hudGroup.responderDiablogueBubble.visible = false;
					}
						
					if (line.responderBodyAnimation != null && line.responderBodyAnimation != "" && line.responderBodyAnimation != "null" && line.responderBodyAnimation != "no action")
					{
						worldGroup.avatars[responderName].clip.gotoAndPlay(line.responderBodyAnimation);
					}
					
					if (line.responderFaceState != "")
					{
						if (line.responderFaceState == "very happy")
						{
							line.responderFaceState = "happy"
						}
						if (line.responderFaceState == "very sad")
						{
							line.responderFaceState = "sad"
						}
						
						worldGroup.avatars[responderName].clip.faceMC.currentState = line.responderFaceState;
					}
					if (line.responderFaceAnimation != null && line.responderFaceAnimation != "null" && line.responderFaceAnimation != "no action" && line.responderFaceAnimation != "")
					{
						//Debug.debug(this, "updatePerformance() Setting faceAnim to " + line.responderFaceAnimation);
						worldGroup.avatars[responderName].clip.faceMC.playAnim(line.responderFaceAnimation);
					}
					else
					{
						//Debug.debug(this, "updatePerformance() ********* Going to state " + worldGroup.avatars[responderName].clip.faceMC.currentState);
						worldGroup.avatars[responderName].clip.faceMC.goToState();
					}	
					/*
					if (Math.random() < PromWeek.GameEngine.UTTERANCE_FREQUENCY  && !initiatorMadeSound)
					{
						if (line.responderFaceState == "idle") {
							if (cif.cast.getCharByName(responderName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["idle"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["idle"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator idle sound should be played");
						}
						if (line.responderFaceState == "angry") {
							if (cif.cast.getCharByName(responderName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["angry"]() as Sound;
							}
							else 
							{
								sound = new soundLibrary.femaleUtterances["angry"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator angry sound should be played");
						}
						if (line.responderFaceState == "anxious") {
							if (cif.cast.getCharByName(responderName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["anxious"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["anxious"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator anxious sound should be played");
						}
						if (line.responderFaceState == "concerned") {
							if (cif.cast.getCharByName(responderName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["concerned"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["concerned"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator concerned sound should be played");
						}
						if (line.responderFaceState == "disinterested") {
							if (cif.cast.getCharByName(responderName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["disinterested"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["disinterested"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator disinterested sound should be played");
						}
						if (line.responderFaceState == "happy") {
							if (cif.cast.getCharByName(responderName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["happy"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["happy"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator happy sound should be played");
						}
						if (line.responderFaceState == "veryHappy") {
							if (cif.cast.getCharByName(responderName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["veryHappy"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["veryHappy"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator very happy sound should be played");
						}
						if (line.responderFaceState == "resentful") {
							if (cif.cast.getCharByName(responderName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["resentful"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["resentful"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator resentful sound should be played");
						}
						if (line.responderFaceState == "sad") {
							if (cif.cast.getCharByName(responderName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["sad"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["sad"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator sad sound should be played");
						}
						if (line.responderFaceState == "verySad") {
							if (cif.cast.getCharByName(responderName).hasTrait(Trait.MALE))
							{
								sound = new soundLibrary.maleUtterances["verySad"]() as Sound;
							}
							else
							{
								sound = new soundLibrary.femaleUtterances["verySad"]() as Sound;
							}
							sound.play();//1000, 3);
							//Debug.debug(this, "Initiator very sad sound should be played");
						}
					}
					*/
					//Debug.debug(this, "-- RESPONDER --");
					//Debug.debug(this, "updatePerformance() line: \"" + line.responderLine + "\"");
					//Debug.debug(this, "updatePerformance() body: " + line.responderBodyAnimation);
					//Debug.debug(this, "updatePerformance() faceAnim: " + line.responderFaceAnimation);
					//Debug.debug(this, "updatePerformance() faceState: " + line.responderFaceState);
					//Debug.debug(this, "updatePerformance() currentState: " + worldGroup.avatars[responderName].clip.faceMC.currentState);
					
					//Now to deal with OTHER speaking!
					if (line.otherLine != "")
					{
						Debug.debug(this, otherName + ": " + line.otherLine);
						//hudGroup.responderDiablogueBubble.pointLeft = true;
						
						//find out whether or not this dialogue bubble should appear on the left or the right.
						if (hudGroup.initiatorDiablogueBubble.visible) {
							if (hudGroup.initiatorDiablogueBubble.pointLeft) { // init is visible AND points left -- other should point right
								hudGroup.otherDialogueBubble.pointRight = true;
							}
							else if (hudGroup.initiatorDiablogueBubble.pointRight) { // init is visible AND points right -- other should point left
								hudGroup.otherDialogueBubble.pointLeft = true;
							}
							//Debug.debug(this, "init is visible");
							//Debug.debug(this, "init bubble is left: " + hudGroup.initiatorDiablogueBubble.pointLeft +  " respond bubble is left: " + hudGroup.responderDiablogueBubble.pointLeft + " other bubble is left: " + hudGroup.otherDialogueBubble.pointLeft);
						}
						else if (hudGroup.responderDiablogueBubble.visible) { // respond is visible
							if (hudGroup.responderDiablogueBubble.pointLeft) { // respond is visible AND points left -- other should point right
								hudGroup.otherDialogueBubble.pointRight = true;
							}
							else if (hudGroup.responderDiablogueBubble.pointRight) { // respond is visible AND points right -- other should point left
								hudGroup.otherDialogueBubble.pointLeft = true;
							}	
							//Debug.debug(this, "respond is visible");
							//Debug.debug(this, "init bubble is left: " + hudGroup.initiatorDiablogueBubble.pointLeft +  " respond bubble is left: " + hudGroup.responderDiablogueBubble.pointLeft + " other bubble is left: " + hudGroup.otherDialogueBubble.pointLeft);
						}
						
						hudGroup.otherDialogueBubble.thought = line.otherIsThought;
						hudGroup.otherDialogueBubble.text = LineOfDialogue.preprocessLine(line.otherLine);
						hudGroup.otherDialogueBubble.updateLocation(); // What does this do -- it updates the graphical location. Look inside DialogueBubble.as
						
						
						
						//BASED ON OUR 'IMPLICIT RULES' THAT WE WERE TALKING ABOUT, WE MAY HAVE TO MAKE IT SO THAT
						//WE ARE AWARE OF WHO IS TALKING AND WHO ISN'T TALKING (INITIATOR/RESPONDER) WISE AND THEN
						//POSITION THE OTHER DIALOGUE BUBBLE IN WHATEVER THE APPROPRIATE SPOT IS.
						//That is to say, not all three people can be talking at the same time.
						//If Init and other are talking, the other dialogue bubble goes where the responder normally would go.
						//And if other and Responder are talking, the bubble goes over on the initiator side.
						
						//ALSO have to somehow take into account 'To Responder' or 'To Initiator'
						//Though maybe that is covered by 'update facing' already?
						hudGroup.otherDialogueBubble.visible = true;

					}
					else
					{
						hudGroup.otherDialogueBubble.visible = false;
					}
						
					
					//Dealing with having the other actually walk in and out of the scene.
					//Need to figure out the numbers, but this works!!!!!
					//OK.. I think I see one thing that is happening at least...
					//We don't know where initiator and responder will be (who is on left, who is on right)
					//sO, to find the true middle, I guess we need to find farRight = max(init.x, respond.x)
					//distance = abs(init.x-respond.x)
					//other.x = farRight - (distance/2)
					//OK... that does make a little more sense.
					//(and in the future, we are interested in having the initiator walk to other places, far away (i.e. the initiator walks up to the responder, and thus it is not taking place in the center of the screen), but this should still help deal with this.

					//if (line.initiatorLine == "It's be my pleasure, hot stuff. Just take my arm and...")
					//{
						//trace("----------");
					//}

					if (otherName != null && otherName != "null" && otherName != "") {
						//if (currentLevel.isCharacterInThisLevel(otherName)) {
						if (line.otherApproach) {
							var farRight:int = Math.max(worldGroup.avatars[initiatorName].locX, worldGroup.avatars[responderName].locX);
							var distance:int = Math.abs(worldGroup.avatars[initiatorName].locX - worldGroup.avatars[responderName].locX);
							var otherX:int = farRight - (distance / 2);
							worldGroup.avatars[otherName.toLowerCase()].moveToLocation(otherX, worldGroup.avatars[initiatorName].locY + - 150);
							//Debug.debug(this, "Can I go like this:" + worldGroup.avatars[otherName.toLowerCase()].state);
							
							
							//Hokay.  I think here we, as before with the 'initiator teleport' stuff, we want to potentially have
							//the approaching other break the laws of time and space.
							//First we need to find out if the other is 'off camera' and even needs to be teleported.
							//And if they are, then we will actually DO the teleportation!
							if (this.camera.isAvatarCurrentlyWhereCameraIsGoingToBe(worldGroup.avatars[otherName.toLowerCase()])) {
								//Debug.debug(this, "TRUE! OTHER WAS on camera!  No teleportation was necessary!");
							}
							else {
								//Debug.debug(this, "FALSE! other NOT on camera!  Teleportation would have been nice!");
								worldGroup.avatars[otherName.toLowerCase()].handleTeleport(camera, tempCameraX, tempCameraY);
							}
							
				
							
						}
						else if (line.otherExit) {
							worldGroup.avatars[otherName.toLowerCase()].moveToLocation(worldGroup.avatars[otherName.toLowerCase()].homeLocX, worldGroup.avatars[otherName.toLowerCase()].homeLocY);
						}
						//}
					}
					
					//Now we deal with 'other' taking part in social games.
					//We only want to do it if the following is ture:
					//1.)They are IN this level.
					//2.)They have 'Entered'
					//It is possible that we could get away with only looking at whether or not they have entered yet.
					//Geeze... that might be like, a big thing that has to get taken care of... when deciding who should play the 'other'
					//making sure that you select someone who is actually IN the level if they have lines of dialogue. Gross.
					
					//We only have to deal with this if this instantiation NEEDS an other to perform.
					if(currentDialogueInstantiation.requiresOtherToPerform()){
					
						//Anyway, first lets just find out if the other has approached or not.					
						var otherHasApproached:Boolean = false;
						
						//for (var i:int = 0; i <= line.lineNumber; i++) {
						for each(var l:LineOfDialogue in currentDialogueInstantiation.lines) {
							if(l.lineNumber <= line.lineNumber) { // we only want to look up to the current line of dialogue, I think.
								if (l.otherApproach) {
									otherHasApproached = true;
									otherDeparted = true;
								}
								else if (l.otherExit) {
									otherHasApproached = false;
								}
							}
							else {
								break;
							}
						}
						
						//Debug.debug(this, "other has approached is: " + otherHasApproached);
						
						if (otherHasApproached && otherArrived) { // only play these animations if the other has actually arrived
							//I think we want to update the way that the other is facing, here.
							if (line.otherAddressing == "initiator") {
								if (worldGroup.avatars[otherName.toLowerCase()].locX < worldGroup.avatars[initiatorName.toLowerCase()].locX) {
									//want to talk to initiator, who is 'more to the right' than we are -- we should face right.
									worldGroup.avatars[otherName.toLowerCase()].lookingAtTarget = "right";
								}
								else {
									worldGroup.avatars[otherName.toLowerCase()].lookingAtTarget = "left";
								}
							}
							else if (line.otherAddressing == "responder") {
								if (worldGroup.avatars[otherName.toLowerCase()].locX < worldGroup.avatars[responderName.toLowerCase()].locX) {
									//want to talk to initiator, who is 'more to the right' than we are -- we should face right.
									worldGroup.avatars[otherName.toLowerCase()].lookingAtTarget = "right";
								}
								else {
									worldGroup.avatars[otherName.toLowerCase()].lookingAtTarget = "left";
								}
							}
							
							if (line.otherBodyAnimation != null && line.otherBodyAnimation != "" && line.otherBodyAnimation != "null" && line.otherBodyAnimation != "no action")
							{
								worldGroup.avatars[otherName.toLowerCase()].clip.gotoAndPlay(line.otherBodyAnimation);
							}
							
							if (line.otherFaceState != "")
							{
								if (line.otherFaceState == "very happy")
								{
									line.otherFaceState = "happy"
								}
								if (line.otherFaceState == "very sad")
								{
									line.otherFaceState = "sad"
								}
								worldGroup.avatars[otherName.toLowerCase()].clip.faceMC.currentState = line.otherFaceState;
							}
							
							if (line.otherFaceAnimation != null && line.otherFaceAnimation != "" && line.otherFaceAnimation != "null" && line.otherFaceAnimation != "no action")
							{
								//Debug.debug(this, "updatePerformance() Setting faceAnim to " + line.responderFaceAnimation);
								worldGroup.avatars[otherName.toLowerCase()].clip.faceMC.playAnim(line.otherFaceAnimation);
							}
							else
							{
								//Debug.debug(this, "updatePerformance() ********* Going to state " + worldGroup.avatars[responderName].clip.faceMC.currentState);
								worldGroup.avatars[otherName.toLowerCase()].clip.faceMC.goToState();
							}	
						}
					}
					
					dialougeLineNumber++;
					
					
					
				}
				else 
				{
					//if we just showed the last line of dialogue
					if (dialougeLineNumber == currentDialogueInstantiation.lines.length)
					{
						//set the timeout times for when the face states should go back to normal.
						worldGroup.avatars[initiatorName.toLowerCase()].hasNonIdleFaceState = true;
						worldGroup.avatars[initiatorName.toLowerCase()].timeFaceStateWasSet = new Date().time;
						worldGroup.avatars[responderName.toLowerCase()].hasNonIdleFaceState = true;
						worldGroup.avatars[responderName.toLowerCase()].timeFaceStateWasSet = new Date().time;
						if (otherName != "" && currentDialogueInstantiation.requiresOtherToPerform())
						{							
							worldGroup.avatars[otherName.toLowerCase()].hasNonIdleFaceState = true;
							worldGroup.avatars[otherName.toLowerCase()].timeFaceStateWasSet = new Date().time;
						}
						
						
						hudGroup.initiatorDiablogueBubble.visible = false;
						hudGroup.responderDiablogueBubble.visible = false;
						hudGroup.otherDialogueBubble.visible = false;
						
						//dialougeLineNumber++;
						
						dialougeLineNumber = 0;
						
						this.currentState = "Results";	
					}
				}
			}
		}

		
		public static function getRomanceColor():Number {
			return ROMANCE_COLOR;
		}

		public static function getBuddyColor():Number {
			return BUDDY_COLOR;
		}

		
		public static function getCoolColor():Number {
			return COOL_COLOR;
		}
		
		/**
		 * This function returns a vector of dictionaries that have the motives for why a social game was responded to in the way that it was.
		 * Dictionary indices that matter: 'percent' is the weight of the predicate, 'motive' is the natural language name of the predicate. The first
		 * two parameters are the only things that need to be passed in if calling this method outside of gameEngine.
		 * @param	context the social game context of the game you are interested in hearing the motivations for
		 * @param	displayAllMotives if true, will display every single motive and its weight.  if false (default) it will only display the top 6
		 * @param	latestRespondContext this is generated by calling cif.getPredicateRelevance.  You only need to worry about this if calling from outside of gameengine, otherwise leave this null, as gameEngine already has the information it needs
		 * @param	initName the actual character name of the initiator of the social game
		 * @param	respondName the actual character name of the responder of the social game
		 * @return a vector of dictionaries. dictionary["percent"] is the weight of the predicate, dictionary["motive"] is the natural language name of the predicate.
		 */
		public function getInitiatorMotives(context:SocialGameContext, displayAllMotives:Boolean = false, latestInitContext:Vector.<RuleRecord> = null, initName:String = null, respondName:String=null):Vector.<Dictionary> {
			var justificationsToDisplay:int = 6;
			var medLow:Boolean = false; // Specifically looking for the number 33
			var medHigh:Boolean = false; // Specifically looking for the number 66
			var primaryName:String;
			var secondaryName:String;
			var thirdName:String;
			var returnVector:Vector.<Dictionary> = new Vector.<Dictionary>();
			var currentDictionary:Dictionary;
			hudGroup.socialGameResultsUI.whyDidInitDoThatRichText.text = "Why did " + upperCaseInitName + " want to do that?";
			hudGroup.socialGameResultsUI.whyDidInitDoThatListRichText.text = "";
			var ruleRecordOtherName:String;
			
			//we will normally have initiatiatorName if we are calling this from gameEnging, we might not otherwise.
			if(!initName)
				var upperCaseInitName:String = initiatorName.charAt(0).toUpperCase() + initiatorName.substring(1, initiatorName.length);
			else
				upperCaseInitName = initName;
				
			
			if (latestInitContext) {
				if (displayAllMotives) justificationsToDisplay = latestInitContext.length;
				//use our custom one.
				for (var i:int = 0; ((i < justificationsToDisplay) && (i < latestInitContext.length)); i++)
				{
					currentDictionary = new Dictionary();
					//Make sure that mediums are not duplicated.
					var pred:Predicate = latestInitContext[i].influenceRule.predicates[0];
					
					if (isBoringMotivePredicate(pred)) continue;
					
					ruleRecordOtherName = latestInitContext[i].other;
					if (pred.type == Predicate.NETWORK && pred.networkValue == 33) medLow = true;
					else if (pred.type == Predicate.NETWORK && pred.networkValue == 67) medHigh = true;
					if (medLow && medHigh) { // Should only get here ON THE TURN that the switch is made.
						medLow = false;
						medHigh = false;
						justificationsToDisplay++; // If we don't do this, we will only have a maximum of five! Now we can get our 
						continue; // Go to the next iteration in the loop, because we already got it's mate!
					}
					
					hudGroup.socialGameResultsUI.whyDidInitDoThatListRichText.text +=  latestInitContext[i].influenceRule.weight + "% ";
					
					currentDictionary["percent"] = latestInitContext[i].influenceRule.weight;
					
					primaryName = "";
					secondaryName = "";
					thirdName = "";
					
					if (pred.primary  == "initiator") primaryName = upperCaseInitName;
					else if (pred.primary == "responder") primaryName = respondName;
					else if (pred.primary == "other") primaryName = ruleRecordOtherName;
					if (pred.secondary  == "initiator") secondaryName = upperCaseInitName;
					else if (pred.secondary == "responder") secondaryName = respondName;
					else if (pred.secondary == "other") secondaryName = ruleRecordOtherName;
					if (pred.tertiary  == "initiator") thirdName = upperCaseInitName;
					else if (pred.tertiary == "responder") thirdName = respondName;
					else if (pred.tertiary == "other") thirdName = ruleRecordOtherName;
					
					hudGroup.socialGameResultsUI.whyDidInitDoThatListRichText.text += pred.toNaturalLanguageString(primaryName, secondaryName, thirdName) + "\n";
					
					//Insert clever phrases like "my boyfriend" or "my enemy" before character's names.
					var motiveToAdd:String = pred.toNaturalLanguageString(primaryName, secondaryName, thirdName);
					var motiveInLowerCase:String = motiveToAdd.toLowerCase();
					var holdingArea:String = "";
					if (ruleRecordOtherName != "" && ruleRecordOtherName != null) {
						var otherNameIndex:int = motiveInLowerCase.indexOf(ruleRecordOtherName.toLowerCase());
						var finalMotiveString:String = "";
						if (otherNameIndex != -1) {
							
							motiveToAdd = swapInitiatorAndOtherPositionInString(motiveToAdd, otherNameIndex, initName, ruleRecordOtherName);
							
							//Check to see if there is any relationship with the initaitor.
							
							if (finalMotiveString == "") finalMotiveString = getInsertRelationshipIntoMotive(RelationshipNetwork.DATING, initName, respondName, ruleRecordOtherName, motiveToAdd, false, pred);
							if (finalMotiveString == "") finalMotiveString = getInsertRelationshipIntoMotive(RelationshipNetwork.DATING, initName, respondName, ruleRecordOtherName, motiveToAdd, true, pred);
							if(finalMotiveString == "") finalMotiveString = getInsertRelationshipIntoMotive(RelationshipNetwork.FRIENDS, initName, respondName, ruleRecordOtherName, motiveToAdd, false, pred);
							if(finalMotiveString == "") finalMotiveString = getInsertRelationshipIntoMotive(RelationshipNetwork.ENEMIES, initName, respondName, ruleRecordOtherName, motiveToAdd, false, pred);
							if(finalMotiveString == "") finalMotiveString = getInsertRelationshipIntoMotive(RelationshipNetwork.FRIENDS, initName, respondName, ruleRecordOtherName, motiveToAdd, true, pred);
							if (finalMotiveString == "") finalMotiveString = getInsertRelationshipIntoMotive(RelationshipNetwork.ENEMIES, initName, respondName, ruleRecordOtherName, motiveToAdd, true, pred);
							if (finalMotiveString == "") finalMotiveString = motiveToAdd; // just the default -- don't change anything.
							
							motiveToAdd = finalMotiveString;
						}
					}
					
					currentDictionary["motive"] = motiveToAdd; //holdingArea; // pred.toNaturalLanguageString(primaryName, secondaryName, thirdName)
					returnVector.push(currentDictionary);
				}
			}
			else {
				if (displayAllMotives) justificationsToDisplay = latestInitiatorPredicateRelevance.length;
				//This is the 'original' one.  Not deleted because I am scared to delete things without being able to test that the new way is perfect.
				for (i = 0; ((i < justificationsToDisplay) && (i < latestInitiatorPredicateRelevance.length)); i++)
				{
					currentDictionary = new Dictionary();
					//Make sure that mediums are not duplicated.
					pred = latestInitiatorPredicateRelevance[i].influenceRule.predicates[0];
					ruleRecordOtherName = latestInitiatorPredicateRelevance[i].other;
					if (pred.type == Predicate.NETWORK && pred.networkValue == 33) medLow = true;
					else if (pred.type == Predicate.NETWORK && pred.networkValue == 67) medHigh = true;
					if (medLow && medHigh) { // Should only get here ON THE TURN that the switch is made.
						medLow = false;
						medHigh = false;
						justificationsToDisplay++; // If we don't do this, we will only have a maximum of five! Now we can get our 
						continue; // Go to the next iteration in the loop, because we already got it's mate!
					}
					
					hudGroup.socialGameResultsUI.whyDidInitDoThatListRichText.text +=  latestInitiatorPredicateRelevance[i].influenceRule.weight + "% ";
					currentDictionary["percent"] = latestInitiatorPredicateRelevance[i].influenceRule.weight;
					
					primaryName = "";
					secondaryName = "";
					thirdName = "";
					
					if (pred.primary  == "initiator") primaryName = initiatorName;
					else if (pred.primary == "responder") primaryName = responderName;
					else if (pred.primary == "other") primaryName = ruleRecordOtherName;
					if (pred.secondary  == "initiator") secondaryName = initiatorName;
					else if (pred.secondary == "responder") secondaryName = responderName;
					else if (pred.secondary == "other") secondaryName = ruleRecordOtherName;
					if (pred.tertiary  == "initiator") thirdName = initiatorName;
					else if (pred.tertiary == "responder") thirdName = responderName;
					else if (pred.tertiary == "other") thirdName = ruleRecordOtherName;
					
					hudGroup.socialGameResultsUI.whyDidInitDoThatListRichText.text += pred.toNaturalLanguageString(primaryName, secondaryName, thirdName) + "\n";	
					currentDictionary["motive"] = pred.toNaturalLanguageString(primaryName, secondaryName, thirdName);
					returnVector.push(currentDictionary);
				}
			}
			
			var motivationString:String;
			/*
			if (Math.abs(context.initiatorScore) < 4)
			{
				motivationString = "weak"
			}
			else if (Math.abs(context.initiatorScore) < 10)
			{
				motivationString = "medium"
			}
			else
			{
				motivationString = "strong"
			}
			*/
			
			motivationString = getIntensityOfDesireToDoWhatTheCharacterDid("initiator", context);
			return returnVector;
			//sfdbEntryUI.initiatorMotives = upperCaseInitName + "'s Motives (motivation " + motivationString + ")\n" + hudGroup.socialGameResultsUI.whyDidInitDoThatListRichText.text;
			//return upperCaseInitName + "'s Motives (motivation " + motivationString + ")\n" + hudGroup.socialGameResultsUI.whyDidInitDoThatListRichText.text;
					
		}
		
		/**
		 * This function returns a vector of dictionaries that have the motives for why a social game was responded to in the way that it was.
		 * Dictionary indices that matter: 'percent' is the weight of the predicate, 'motive' is the natural language name of the predicate. The first
		 * two parameters are the only things that need to be passed in if calling this method outside of gameEngine.
		 * @param	context the social game context of the game you are interested in hearing the motivations for
		 * @param	displayAllMotives if true, will display every single motive and its weight.  if false (default) it will only display the top 6
		 * @param	latestRespondContext this is generated by calling cif.getPredicateRelevance.  You only need to worry about this if calling from outside of gameengine, otherwise leave this null, as gameEngine already has the information it needs
		 * @param	initName the actual character name of the initiator of the social game
		 * @param	respondName the actual character name of the responder of the social game
		 * @return a vector of dictionaries. dictionary["percent"] is the weight of the predicate, dictionary["motive"] is the natural language name of the predicate.
		 */
		public function getResponderMotives(context:SocialGameContext, displayAllMotives:Boolean = false, latestRespondContext:Vector.<RuleRecord> = null, initName:String = null, respondName:String = null):Vector.<Dictionary> {
			var medLow:Boolean = false; // Specifically looking for the number 33
			var medHigh:Boolean = false; // Specifically looking for the number 66
			var primaryName:String;
			var secondaryName:String;
			var thirdName:String;
			var returnVector:Vector.<Dictionary> = new Vector.<Dictionary>();
			var currentDictionary:Dictionary;
			
			//If the respondName wasn't passed in, figure out what it is (and make the first letter capitalized)
			if(!respondName)
				var upperCaseRespName:String = responderName.charAt(0).toUpperCase() + responderName.substring(1, responderName.length);
			else
				upperCaseRespName = respondName;
				
			//We don't really use this any more... should probably delete these two lines
			hudGroup.socialGameResultsUI.whyDidRespDoThatRichText.text = "Why did " + upperCaseRespName + " react that way?";
			hudGroup.socialGameResultsUI.whyDidRespDoThatListRichText.text = "";
			
			//One of the arguments passed into the function is a boolean "display all motives" -- if true, this value is
			//overridden later on.  If false, tihs is the number of justifications to display.
			var justificationsToDisplay:int = 6; 
			
			//Based on the way this function is called, the 'true' branch of this if statement should ALWAYS evaluate to true.
			//Really, it would be better if there wasn't an if-else here, OR if there was, the else just makes returns an
			//error or warning or something.  But no, code was copy and pasted and I am too scared to delete it lest we find we
			//need it again later.
			//UPSHOT:  The 'true' branch of this if is WHAT YOU CARE ABOUT
			if (latestRespondContext) {
				if (displayAllMotives) justificationsToDisplay = latestRespondContext.length;
				//We go through the loop one time for every motive we want to display.
				for (var i:int = 0; ((i < justificationsToDisplay) && (i < latestRespondContext.length)); i++)
				{		
					currentDictionary = new Dictionary(); // this will store the information we care about for this specific predicate.
					var pred:Predicate = latestRespondContext[i].influenceRule.predicates[0]; //each rule record has an influence rule with a single predicate.
					var ruleRecordOtherName:String = latestRespondContext[i].other; //figure out who the other is.
					
					
					//Make sure mediums are not duplicated.
					if (pred.type == Predicate.NETWORK && pred.networkValue == 33) medLow = true;
					else if (pred.type == Predicate.NETWORK && pred.networkValue == 67) medHigh = true;
					if (medLow && medHigh) { // Should only get here ON THE TURN that the switch is made.
						medLow = false;
						medHigh = false;
						justificationsToDisplay++; // If we don't do this, we will only have a maximum of five! Now we can get our 
						continue; // Go to the next iteration in the loop, because we already got it's mate!
					}
					
					//More cruft from the past that should probably be deleted.
					hudGroup.socialGameResultsUI.whyDidRespDoThatListRichText.text += latestRespondContext[i].influenceRule.weight + "% ";
					
					//The calculation of the 'weight' of the rule record already has taken the 'percent' stuff into
					//account, so let's store it in our 'currentDictionary"
					currentDictionary["percent"] = latestRespondContext[i].influenceRule.weight;
					
					//Now we figure out who the 'primary', 'secondary', and 'thirdary' people are.
					primaryName = "";
					secondaryName = "";
					thirdName = "";
					
					//We have to do weird role switching here, becuase the 'responder' fo the game is the 'initiator'
					//from their own predicates perspective... or something.
					if (pred.primary  == "initiator") primaryName = upperCaseRespName ;
					else if (pred.primary == "responder") primaryName = initName;
					
					else if (pred.primary == "other") primaryName = ruleRecordOtherName;
					
					if (pred.secondary  == "initiator") secondaryName = upperCaseRespName ;
					else if (pred.secondary == "responder") secondaryName = initName ;
					
					else if (pred.secondary == "other") secondaryName = ruleRecordOtherName;
					
					if (pred.tertiary  == "initiator") thirdName = upperCaseRespName;
					else if (pred.tertiary == "responder") thirdName = initName ;
					
					else if (pred.tertiary == "other") thirdName = ruleRecordOtherName;
					
					//Yet more garabage that we don't really care about!
					hudGroup.socialGameResultsUI.whyDidRespDoThatListRichText.text += pred.toNaturalLanguageString(primaryName, secondaryName, thirdName) + "\n";
					
					//Now we store the actual motive itself (e.g. "Monica is a sex magnet").  We figure that out by generating the
					//natural language version of the predicate that we are looking at!
					
					//Insert clever phrases like "my boyfriend" or "my enemy" before character's names.
					var motiveToAdd:String = pred.toNaturalLanguageString(primaryName, secondaryName, thirdName);
					var motiveInLowerCase:String = motiveToAdd.toLowerCase();
					if (ruleRecordOtherName != "" && ruleRecordOtherName != null) {
						var otherNameIndex:int = motiveInLowerCase.indexOf(ruleRecordOtherName.toLowerCase());
						var finalMotiveString:String = "";
						if (otherNameIndex != -1) {
							
							motiveToAdd = swapInitiatorAndOtherPositionInString(motiveToAdd, otherNameIndex, respondName, ruleRecordOtherName);
							
							//Check to see if there is any relationship with the initaitor.
							
							if (finalMotiveString == "") finalMotiveString = getInsertRelationshipIntoMotive(RelationshipNetwork.DATING, respondName, initName, ruleRecordOtherName, motiveToAdd, true, pred);
							if (finalMotiveString == "") finalMotiveString = getInsertRelationshipIntoMotive(RelationshipNetwork.DATING, respondName, initName,  ruleRecordOtherName, motiveToAdd, false, pred);
							if(finalMotiveString == "") finalMotiveString = getInsertRelationshipIntoMotive(RelationshipNetwork.FRIENDS, respondName, initName,  ruleRecordOtherName, motiveToAdd, true, pred);
							if(finalMotiveString == "") finalMotiveString = getInsertRelationshipIntoMotive(RelationshipNetwork.ENEMIES, respondName, initName,  ruleRecordOtherName, motiveToAdd, true, pred);
							if(finalMotiveString == "") finalMotiveString = getInsertRelationshipIntoMotive(RelationshipNetwork.FRIENDS, respondName, initName,  ruleRecordOtherName, motiveToAdd, false, pred);
							if (finalMotiveString == "") finalMotiveString = getInsertRelationshipIntoMotive(RelationshipNetwork.ENEMIES, respondName, initName,  ruleRecordOtherName, motiveToAdd, false, pred);
							if (finalMotiveString == "") finalMotiveString = motiveToAdd; // just the default -- don't change anything.
							
							motiveToAdd = finalMotiveString;
						}
					}
					currentDictionary["motive"] = motiveToAdd; // pred.toNaturalLanguageString(primaryName, secondaryName, thirdName);
					
					//Add this dictionary representing this predicate's information to the vector that we will eventually return!
					returnVector.push(currentDictionary);
				}
			}
			else { //I THINK THIS BLOCK SHOULD BE DELETED AND/OR REPLACED WITH some error message... we shouldn't be getting in here.
				if (displayAllMotives) justificationsToDisplay = latestResponderPredicateRelevance.length;
				//do it the normal way
				for (i = 0; ((i < justificationsToDisplay) && (i < latestResponderPredicateRelevance.length)); i++)
				{		
					currentDictionary = new Dictionary();
					pred = latestResponderPredicateRelevance[i].influenceRule.predicates[0];
					ruleRecordOtherName = latestResponderPredicateRelevance[i].other;
					
					
					//Make sure mediums are not duplicated.
					if (pred.type == Predicate.NETWORK && pred.networkValue == 33) medLow = true;
					else if (pred.type == Predicate.NETWORK && pred.networkValue == 67) medHigh = true;
					if (medLow && medHigh) { // Should only get here ON THE TURN that the switch is made.
						medLow = false;
						medHigh = false;
						justificationsToDisplay++; // If we don't do this, we will only have a maximum of five! Now we can get our 
						continue; // Go to the next iteration in the loop, because we already got it's mate!
					}
					
					hudGroup.socialGameResultsUI.whyDidRespDoThatListRichText.text += latestResponderPredicateRelevance[i].influenceRule.weight + "% ";
					currentDictionary["percent"] = latestResponderPredicateRelevance[i].influenceRule.weight;
					
					primaryName = "";
					secondaryName = "";
					thirdName = "";
					
					//Have to do weird role switching, because the responder is the initiator
					//from their own perspective (or something like that).
					if (pred.primary  == "initiator") primaryName = responderName;
					else if (pred.primary == "responder") primaryName = initiatorName;
					
					else if (pred.primary == "other") primaryName = ruleRecordOtherName;
					
					if (pred.secondary  == "initiator") secondaryName = responderName;
					else if (pred.secondary == "responder") secondaryName = initiatorName ;
					
					else if (pred.secondary == "other") secondaryName = ruleRecordOtherName;
					
					if (pred.tertiary  == "initiator") thirdName = responderName ;
					else if (pred.tertiary == "responder") thirdName = initiatorName;
					
					else if (pred.tertiary == "other") thirdName = ruleRecordOtherName;
					
					hudGroup.socialGameResultsUI.whyDidRespDoThatListRichText.text += pred.toNaturalLanguageString(primaryName, secondaryName, thirdName) + "\n";
					currentDictionary["motive"] = pred.toNaturalLanguageString(primaryName, secondaryName, thirdName);
					returnVector.push(currentDictionary);
				}
			}
			
			//We can also get the relative strength of how badly this person wanted to accept or reject the social game
			var motiveStrength:String = getIntensityOfDesireToDoWhatTheCharacterDid("responder", context);
			
			//Yay! We have a vector of dictionaries representing the motives!  Return that beautiful treasure!
			return returnVector;
			
			//return upperCaseRespName + "'s Motives (reaction " + reactionString + ")\n" + hudGroup.socialGameResultsUI.whyDidRespDoThatListRichText.text;
		}
		
		/**
		 * Given either 'initiator' or 'responder', looks at the initiator or responders
		 * scores and converts that into a descriptive string (e.g. "strong", "weak", etc.)
		 * @param	role either initiator or responder, the role that you are interested in.
		 * @param context the social game context that you are interested in getting the motive strength for.
		 * @return 'strong', 'weak' or 'medium'
		 */
		public function getIntensityOfDesireToDoWhatTheCharacterDid(role:String, context:SocialGameContext):String {
			var WEAK_THRESHOLD:int = 4;
			var MEDIUM_THRESHOLD:int = 10;
			var reactionString:String = "";
			var theScore:int;
			if (role.toLowerCase() == "responder") {
				theScore = context.responderScore;
			}
			else if (role.toLowerCase() == "initiator") {
				theScore = context.initiatorScore;
			}
			else {
				//Debug.debug(this, "getIntensityOfDesireToDoWhatTheCharacterDid(), unknown role! Error! Should only be initiator or responder!");
			}
			
			if (Math.abs(theScore) < WEAK_THRESHOLD)
			{
				reactionString = "weak"
				//Debug.debug(this, "getIgetIntensityOfDesireToDoWhatTheCharacterDid() WEAK score is: " + theScore + " game is: " + context.gameName);
			}
			else if (Math.abs(theScore) < MEDIUM_THRESHOLD)
			{
				reactionString = "medium"
				//Debug.debug(this, "getIgetIntensityOfDesireToDoWhatTheCharacterDid() MED score is: " + theScore + " game is: " + context.gameName);
			}
			else
			{
				reactionString = "strong"
				//Debug.debug(this, "getIgetIntensityOfDesireToDoWhatTheCharacterDid() HIGH score is: " + theScore + " game is: " + context.gameName);
			}
			
			return reactionString;
		}		
		
		public function NEW_getIntensityOfDesireToDoWhatTheCharacterDid(role:String, context:SocialGameContext):String {
			var WEAK_THRESHOLD:int = 4;
			var MEDIUM_THRESHOLD:int = 10;
			var reactionString:String = "";
			var theScore:int;
			if (role.toLowerCase() == "responder") {
				theScore = context.responderScore;
			}
			else if (role.toLowerCase() == "initiator") {
				theScore = context.initiatorScore;
			}
			else {
				//Debug.debug(this, "getIntensityOfDesireToDoWhatTheCharacterDid(), unknown role! Error! Should only be initiator or responder!");
			}
			
			if (Math.abs(theScore) < WEAK_THRESHOLD)
			{
				reactionString = "... kinda"
				//Debug.debug(this, "getIgetIntensityOfDesireToDoWhatTheCharacterDid() WEAK score is: " + theScore + " game is: " + context.gameName);
			}
			else if (Math.abs(theScore) < MEDIUM_THRESHOLD)
			{
				reactionString = ""
				//Debug.debug(this, "getIgetIntensityOfDesireToDoWhatTheCharacterDid() MED score is: " + theScore + " game is: " + context.gameName);
			}
			else
			{
				reactionString = "... a lot"
				//Debug.debug(this, "getIgetIntensityOfDesireToDoWhatTheCharacterDid() HIGH score is: " + theScore + " game is: " + context.gameName);
			}
			
			return reactionString;
		}
		/**
		 * Turns the minimap off and on.
		 */
		public function toggleMiniMap():void {
			this.MINI_MAP = !this.MINI_MAP;
			if (this.MINI_MAP) {
				this.miniMap = new PromWeek.MiniMap();			
				this.addElement(this.miniMap);
				this.miniMap.scaleX = 0.1;
				this.miniMap.scaleY = 0.1;
				this.miniMap.x = 50;
				this.miniMap.y = 50;
				//add new UI elements
			}else {
				if (this.miniMap) {
					this.removeElement(this.miniMap);
				}
			}
		}
		
		public function toggleDConsole():void {
			CONFIG::monster {
				this.isDConsoleActive = !this.isDConsoleActive
				if (isDConsoleActive) {
					//if it is becoming active
					if (!this.uiComponent) {
						this.uiComponent = new UIComponent();
					}
					this.addElement(uiComponent);
					uiComponent.addChild(DConsole.view);
					DConsole.show()
					//uiComponent.setFocus();
					focusManager.deactivate()
				}else {
					//if it is becoming inactive
					if (!this.uiComponent) {
						this.removeElement(this.uiComponent);
					}
					DConsole.hide()
					focusManager.deactivate()
				}
			}
		}
		
		/**
		 * This should theoretically set all the styles of all the components called in it when a new color is chosen
		 */
		public function setAllStyles():void {
			hudGroup.storySelectionScreen.setStyleName();
			hudGroup.optionsScreen.setStyleName();
			
			hudGroup.creditsScreen.setStyleName();
			
			hudGroup.mainMenuScreen.setStyleName();
			hudGroup.mainMenuScreen.continuePopUp.setStyleName();
			
			hudGroup.sandboxMenuScreen.setStyleName();
			hudGroup.achievementsScreen.setStyleName();
			
			hudGroup.consolePopUp.setStyleName();
			hudGroup.customAlert.setStyleName();
			hudGroup.helpTips.setStyleName();
			
			hudGroup.skipLevelOptionMenu.setStyleName();
			hudGroup.skipToEndOfPromNight.setStyleName();
			hudGroup.inGameOptionMenu.setStyleName();
			hudGroup.exitStoryButton.setStyleName();
			hudGroup.musicToggleButton.setStyleName();
			hudGroup.bugReporterButton.setStyleName();
			hudGroup.soundEffectsToggleButton.setStyleName();
			hudGroup.updatesGroup.setStyleName();
			
			hudGroup.optionsButton.setStyleName();
			hudGroup.soundButton.setStyleName();
			hudGroup.zoomInButton.setStyleName()
			hudGroup.zoomOutButton.setStyleName();
			
			hudGroup.endingInfoWindow.setStyleName();
			hudGroup.postSGSFDBEntry.setStyleName();
			
			
			hudGroup.ssuVisualizer.styleName = this.activeStyleName;
			
			hudGroup.juiceBar.setStyleName();
			hudGroup.megaUI.setStyleName();
			hudGroup.socialGameButtonRing.setStyleName();
			hudGroup.socialGameButtonRing.sgDropDown.toggler.setStyleName();
			
			hudGroup.storyGoalWindow.setStyleName();
			this.tutorialPopup.setStyleName();
			
			hudGroup.tutorialSelectionScreen.setStyleName();
			hudGroup.levelObjectiveScreen.setStyleName();
			hudGroup.levelResultsScreen.setStyleName();
			hudGroup.endOfStoryScreen.setStyleName();
			
			if (this.useEndingButtons)
			{
				hudGroup.endingWindow.setStyleName();
			}
			
			this.styleToolTips();
			
			//var cssDecl:CSSStyleDeclaration = StyleManager.getStyleDeclaration("mx.controls.ToolTip");
			//if (!cssDecl) {
				//cssDecl = new CSSStyleDeclaration("mx.controls.ToolTip");
			//}
			//cssDecl.setStyle("backgroundAlpha", 1.0);
			//cssDecl.setStyle("backgroundColor", this.getStyle("contentAreaColor"));
			//cssDecl.setStyle("color", "white");
			//cssDecl.setStyle("borderColor", this.getStyle("contentAreaStrokeColor"));
			//
			//cssDecl.setStyle("cornerRadius", 2);
			//cssDecl.setStyle("fontSize", 24);
			//cssDecl.setStyle("", this.getStyle("");
			
			//hudGroup.sgInfoWindow.setStyleName();
		}
		
		/**
		 * This is a utility function that maybe already exists.  I'm sorry if it is a repeat.
		 * However, given a predicate that has who the 'primary' is and who the 'secondary' is in terms
		 * of initiator and responder, this function looks inside of the social game context to get what
		 * their name actually is.  This function assumes that the social game context has been created.
		 * Otherwise, it returns a dummy dictionary with bad values
		 * @param	pred the predicate that we want to find the names of the primary person and the secondary person.
		 * @return a dictionary with two values ['primary'] is the NAME of the primary person from the predicate ['secondary'] is the NAME of the secondary person.
		 */
		public function getNamesFromRoles(pred:Predicate):Dictionary {
			var returnDictionary:Dictionary = new Dictionary();
			var latestSGC:SocialGameContext = cif.sfdb.getLatestSocialGameContext();
				
			if (pred.primary.toLowerCase() == "initiator") returnDictionary['primary'] = latestSGC.initiator;
			if (pred.primary.toLowerCase() == "responder") returnDictionary['primary'] = latestSGC.responder;
			if (pred.primary.toLowerCase() == "other") returnDictionary['primary'] = latestSGC.other;
			
			if (pred.secondary.toLowerCase() == "initiator") returnDictionary['secondary'] = latestSGC.initiator;
			if (pred.secondary.toLowerCase() == "responder") returnDictionary['secondary'] = latestSGC.responder;
			if (pred.secondary.toLowerCase() == "other") returnDictionary['secondary'] = latestSGC.other;
			
			/*
			if (pred.primary.toLowerCase() == "initiator") returnDictionary['primary'] = hudGroup.postSGSFDBEntry.sgContext.initiator;
			if (pred.primary.toLowerCase() == "responder") returnDictionary['primary'] = hudGroup.postSGSFDBEntry.sgContext.responder;
			if (pred.primary.toLowerCase() == "other") returnDictionary['primary'] = hudGroup.postSGSFDBEntry.sgContext.other;
			
			if (pred.secondary.toLowerCase() == "initiator") returnDictionary['secondary'] = hudGroup.postSGSFDBEntry.sgContext.initiator;
			if (pred.secondary.toLowerCase() == "responder") returnDictionary['secondary'] = hudGroup.postSGSFDBEntry.sgContext.responder;
			if (pred.secondary.toLowerCase() == "other") returnDictionary['secondary'] = hudGroup.postSGSFDBEntry.sgContext.other;
			*/
			
			/*
			}
			else {
				returnDictionary['primary'] = "NO PRIMARY NAME FOUND!";
				returnDictionary['secondary'] = "NO SECONDARY NAME FOUND!";
			}
			*/
			return returnDictionary;
		}
		
		/**
		 * NOTE: this function is awkwardly named. this function is called whenever a story/level is exited by
		 * any means -- not strictly when we have seen an ending.
		 * 
		 * This is a function that makes it so that, after the player sees an ending, they are
		 * taken back to the campaign selection screen.
		 * @param	event
		 */
		public function sawEnding(event:Event = null):void {
			Debug.debug(this, "They saw an ending!  I think we want this to be very similar to what we did in the tutorial!");
		
			//Update the DATABASE!!?!?!?!?!
			if (this.endingToPerform != null)
			{
				//sometime we call this just to reset the state and go to the main menu. In that case don't worry about the endings
				backend.sendEndingSeen(this.currentStory.storyLeadCharacter, this.endingToPerform.name);
			}
			
			//1.) Revert the social state back to the start state
			resetGameState();
			
			this.hudGroup.storySelectionScreen.selectedStory = null;
			
			//We need to clean out all of the avatars, I guess, because otherwise they won't show up
			//on the campaign selection screen?
			
			//Any characters that were in the middle of fading back into existence--make them come back completely into existence!
			for each(var a:Avatar in this.worldGroup.avatars) {
				a.clip.alpha = 1;
			}
			
			if(this.worldGroup) {
				//this.removeElement(this.worldGroup);
				//this.worldGroup.cleanUp()
			}
			//this.worldGroup = new PromWeek.WorldGroup();
			
			//2) Clean up the UI elements that might be left lingering.
			hudGroup.endingButtons = new Vector.<PromWeekButton>();
			tutorialPopup.visible = false;
			this.tutorialFilter.visible = false;
			hudGroup.socialGameButtonRing.visible = false;
			hudGroup.megaUI.visible = false;
			this.hudGroup.optionsButton.visible = false;
			//this.hudGroup.levelClock.visible = false;
			//hudGroup.topBar.visible = false;
			hudGroup.juiceBar.visible = false;
			hudGroup.resetStateButton.visible = false;
			hudGroup.nextQuickPlayButton.visible = false;
			hudGroup.quickPlayLevelInstructionsLabel.visible = false;
			if (this.useEndingButtons)
			{
				hudGroup.endingWindow.visible = false;
				hudGroup.endingWindow.allTheEndings.removeAllElements();
				hudGroup.endingWindow.endingsCount = 0;
				hudGroup.endingWindow.atleastOneEnding = false;
				hudGroup.endingWindow.setDynamicHeight();
			}
			//hudGroup.goToEndingButton.visible = false;
			endingToPerform = null;
			for (var i:int = 0; i < hudGroup.autonomousActionGroup.numElements; i++){
				hudGroup.autonomousActionGroup.getElementAt(i).visible = false;
			}
			
			//Clean out things like Juice Points and story goals.
			returnToMainMenuCleanUp();
			
			//3.) Transport the player back to the tutorial selection screen.
			//this.hudGroup.storySelectionScreen.loadStorySelection();
			this.hudGroup.storySelectionScreen.changeAvatar(currentStory.storyLeadCharacter);
			this.hudGroup.storySelectionScreen.updateGoalsSeenText(currentStory);
			statisticsManager.unlockCampaigns();
			this.hudGroup.storySelectionScreen.updateNewlyUnlockedCampaigns();
			
			if (this.facadeState)
			{
				this.hudGroup.facadeScreen.leaveFacadeState();
			}
			
			if (this.currentLevel.isSandbox || this.currentStory.isQuickPlay)
			{
				currentState = "MainMenu";
			}
			else
			{
				currentState = "StorySelection";
			}
		}
		
		/**
		 * There are various things that need to be "cleaned up" when the player returns to the main menu
		 after finishing a story or a tutorial.  These include:
		 Goal Vectors
		 Juice Points
		 Some Lingering UI elements that don't seem to get cleaned up.
		 */
		public function returnToMainMenuCleanUp():void {
			//clean up lingering UI elements.
			//for (var i:int = 0; i < hudGroup.updatesGroup.theGroup.numElements; i++) {
				hudGroup.updatesGroup.theGroup.removeAllElements();// removeElementAt(i);
			//}
			hudGroup.updatesGroup.popUpVector = new Vector.<Object>();
			//reset juice points
			jpm.setJuicePoints(jpm.DEFAULT_INITIAL_JUICE_POINTS);
			
			this.possibleEndings = new Vector.<Ending>();
			
			this.hudGroup.ssuVisualizer.scrollerGroup.removeAllElements();
			
			this.timeOfLastSocialStatusUpdate = new Dictionary();
			this.timeTillNextSocialStatusUpdate = new Dictionary();
			
			//"turn off" the vectors that have goal progress information.
			hudGroup.storyGoalWindow.toDoItemAccordion.selectedToDoItemComponent = new PromWeek.ToDoItemComponent();
			hudGroup.storyGoalWindow.toDoItemAccordion.selectedList = new List();
			//goalList.scroller.setStyle("verticalScrollPolicy", ScrollPolicy.ON);
            //hudGroup.storyGoalWindow.toDoItemAccordion.selectedList.setStyle("skinClass", NEW_listScrollSkin);
			hudGroup.storyGoalWindow.toDoItemAccordion.titles = new Vector.<PromWeek.ToggleableContainerButton>(ToggleableContainerButton)
			hudGroup.storyGoalWindow.toDoItemAccordion.ids = new Vector.<CollapsiblePanel>();
			hudGroup.storyGoalWindow.toDoItemAccordion.toDoItemComponents = new Vector.<PromWeek.ToDoItemComponent>();
			hudGroup.storyGoalWindow.toDoItemAccordion.goalLists = new Vector.<List>();
			hudGroup.storyGoalWindow.toDoItemAccordion.dropDownArrows = new Vector.<Image>();
			hudGroup.storyGoalWindow.toDoItemAccordion.tdContainer.removeAllElements();
			hudGroup.storyGoalWindow.toDoItemAccordion.updateToDoList();
		}
		
		/**
		 * Loads a local copy of the game state from a Flash SharedObject. The intent is to have
		 * a local copy backup the copy pulled from the server. The game state from the server will
		 * take priority over the local state.
		 */
		public function loadLocalGameState():void {
			var sm:StatisticsManager = StatisticsManager.getInstance();
			var so:SharedObject = SharedObject.getLocal("goals-seen");
			
			if (so.size > 0)
			{
				if (so.data)
				{
					sm.goalsSeen = so.data.goals as Dictionary;
					Debug.debug(this, "loadLocalGameState() goals were loaded: " + sm.goalsSeen);
					sm.unlockCampaigns();
					return;
				}
			}
			Debug.debug(this, "loadLocalGameState() no goals-seen data was loaded.");
		}
		
		/**
		 * Stores a local copy of the game state to be used as a backup in the case of a bad 
		 * internet connection.
		 */
		public function storeLocalGameState():void {
			var sm:StatisticsManager = StatisticsManager.getInstance();
			var so:SharedObject = SharedObject.getLocal("goals-seen");
			so.data.goals = sm.goalsSeen;
			so.flush();
		}
		
		/**
		 * Inside of quick plays, we want to display 'level objective text' (such as "make Gunter and Naomi friends!") that is printed on the main screen.
		 * It's possible that we might want to do some special logic (such as making it disappear after a set amount of time, or fade in and out or something).
		 * All of that logic should go inside of this function!
		 */
		/*
		public function updateQuickPlayLevelInstructions():void {
			if (visibilityManager.useQuickPlayLevelInstructions) {
				//var tempHGroup:HGroup;
				//HERE (ISH) is where we will deal with the level instructions having icons in them.
				//this.visibilityManager.handleQuickPlayLevelInstructionRendering(this.currentStory.quickPlayDescription);
				
				
				if (!visibilityManager.quickPlayLevelGoalsCompleted) {
					if (!visibilityManager.quickPlayLevelTextHasBeenRendered) {
						if (this.visibilityManager.createGroupWithTextAndImages(this.currentStory.quickPlayDescription, "quickPlayLevelInstructionHGroup", "QuickPlayInstructionStyle", hudGroup.topBar.height, hudGroup.topBar.width / 4, 60, true )) {
							visibilityManager.quickPlayLevelTextHasBeenRendered = true;
						}
					}
				}
				else{
					if (!visibilityManager.quickPlayEndingTextHasBeenRendered) {
						if (this.visibilityManager.createGroupWithTextAndImages(this.currentStory.quickPlayEndingDescription, "quickPlayLevelInstructionHGroup", "QuickPlayInstructionStyle", hudGroup.topBar.height,  hudGroup.topBar.width / 4, 60, true )) {
							visibilityManager.quickPlayEndingTextHasBeenRendered = true;
						}
					}
				}
				//this.visibilityManager.findAComponentInTheThingsToGoOnTopGroup("quickPlayLevelInstructionHGroup");
				
				//hudGroup.quickPlayLevelInstructionsLabel.text = this.currentStory.quickPlayDescription;
				//hudGroup.quickPlayLevelInstructionsLabel.x - hudGroup.quickPlayLevelInstructionsLabel.width/2
			}
		}
		*/
		
		/**
		 * Returns true if all of the goals in a quick play level have been satisfied. False otherwise.
		 * @return 
		 */
		public function checkQuickPlayGoalProgress():Boolean {
			if(!visibilityManager.quickPlayLevelGoalsCompleted){ // only do this check if we haven't confirmed that we've successfully completed all goals.
				for each(var toDoItem:ToDoItem in currentStory.todoList) {
					if (!toDoItem.evaluateCondition())
						return false; // oh oh! They all have to be true for us to care!
				}

				visibilityManager.quickPlayLevelGoalsCompleted = true;
				//updateQuickPlayLevelInstructions();
				//handleQuickPlayFireworksDisplay();
				return true; // If we made it here, then they all must be true!
			}
			return true;
			
		}
		
		/**
		 * Goes through the level cast and removes all autonomous actions that they might
		 * want to play with each other by setting their score to be very low so that they will
		 * be removed at the next call to "dealWithAutonomousActions"
		 */
		public function removeAllAutonomousActions():void {
			for each(var c:Character in this.currentLevel.cast) {
				var a:Avatar = worldGroup.avatars[c.characterName.toLowerCase()]
				if (a.pendingAutonomousAction) {
						//Debug.debug(this,"dealWithAutonomousActions() " + aa.initiator + " no longer REALLY wants to play " + aa.gameName + " with " + aa.responder);
						a.pendingAutonomousAction = null
						
						// nuke the autonomousIcon for this guy
						delete hudGroup.autonomousIcons[a.characterName.toLowerCase()];// = null
				}
			}
			this.hudGroup.autonomousActionGroup.removeAllElements();
			this.hudGroup.autonomousIcons = new Dictionary();
		}
		
		/**
		 * Make fireworks appear when you finish a quickplay level!
		 */
		public function handleQuickPlayFireworksDisplay():void {
			//var fireworksGroup:Group = visibilityManager.findAComponentInTheThingsToGoOnTopGroup("fireworksGroup") as Group;
			this.hudGroup.fireworksGroup.removeAllElements();;
			
			var uiComp:UIComponent = new UIComponent();
			uiComp.width = this.width;
			uiComp.height = this.height;
			
			var emitter:NEW_firework = new NEW_firework();
			var renderer:BitmapRenderer = new BitmapRenderer( new Rectangle( 0, 0, this.width, this.height) );
			renderer.addFilter( new BlurFilter( 2, 2, 1 ) );
			renderer.addFilter( new ColorMatrixFilter( [ 1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0.95,0 ] ) );
			renderer.addEmitter( emitter );
			emitter.x = this.hudGroup.fireworksGroup.width/4;
			emitter.y = this.hudGroup.fireworksGroup.height/4;
			emitter.start();			
			uiComp.addChild(renderer);
			
			emitter = new NEW_firework();
			renderer = new BitmapRenderer( new Rectangle( 0, 0, this.width, this.height) );
			renderer.addFilter( new BlurFilter( 2, 2, 1 ) );
			renderer.addFilter( new ColorMatrixFilter( [ 1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0.95,0 ] ) );
			renderer.addEmitter( emitter );
			emitter.x = 3 * this.hudGroup.fireworksGroup.width/4;
			emitter.y = this.hudGroup.fireworksGroup.height/4;
			emitter.start();			
			uiComp.addChild(renderer);
			
			this.hudGroup.fireworksGroup.addElement(uiComp);
		}
		
		/**
		 * Checks to see what he forced instantiation for this social game is, if any.
		 * Returns the id of the instantiation to play if one was specified in the story XML file,
		 * returns -1 if no instantiation was specified.
		 * 
		 * 
		 * Be careful when specifying instantiations -- if things 'aren't true' (i.e. you specify an instantiation
		 * that involves characters bonding over a CKB item that they both 'like', but one doesn't actually exist,
		 * you'll get unexpected behavior).  Definitely make sure you check the 'effect conditions' of the effect
		 * that is linked to the instantiation that you want to show up... and do your best to make sure that they
		 * are in fact going to be true.
		 * 
		 * Also -- this function should only be called if the user did NOT
		 * negate the responder score.  If they did switch the responder's response, all bets are off and it should
		 * just use the instantiation it wanted to use in the first place.
		 * @return the ID of the instantiation to use, or -1 if no instantiation was specified.
		 */
		public function getForcedInstantiationID(sg:SocialGame):int {
			for each(var forcedSG:ForcedSG in currentStory.forcedSGs) {
				if (forcedSG.gameName.toLowerCase() == sg.name.toLowerCase()) { // make sure we are dealing with the same game
					if(forcedSG.turnsIn == cif.time){ // make sure we are dealing with the right time.
						if (forcedSG.initiator.toLowerCase() == primaryAvatarSelection.toLowerCase() && forcedSG.responder.toLowerCase() == secondaryAvatarSelection.toLowerCase()) {
							//make sure that we are dealing with the right characterss
							return forcedSG.instantiationID; // If we got here, then I think we've found it!
						}
					}
				}
			}
			return -1; // if we get here, then it must not have been specified.
		}
		
		/**
		 * Checks to see if this is a 'boring' predicate to include in an intiator or responder's motives.
		 * Likely candidates might include lines such as "I have something" or "I did something recently"
		 * If it is boring, this function returns true.  Returns false otherwise.
		 * @param	pred the predicate to check to see if it is boring or not.
		 * @return returns true if the predicate is deemed boring.  False otherwise.
		 */
		public function isBoringMotivePredicate(pred:Predicate):Boolean {
			if (pred.type == Predicate.CKBENTRY) {
				if (pred.firstSubjectiveLink != "") { // so the primary person has a relationship to something (they like it, they have it, etc.)
					if (pred.secondSubjectiveLink == "" && pred.truthLabel == "") {
						//they specified only the primary's relationship to the thing! no way!
						return true;
					}
				}
				if (pred.secondSubjectiveLink != "") {
					if (pred.firstSubjectiveLink == "" && pred.truthLabel == "") {
						////they specified only the secondary's relationship to the thing! no way!
						return true;
					}
				}
			}
			else if (pred.type == Predicate.SFDBLABEL) {
				if (SocialFactsDB.getLabelByNumber(pred.sfdbLabel) == "") {
					return true; // it was an SFDB label predicate that apparantly didn't have a label specified? I don't get it... it is weird.
				}
			}
			
			return false; // I guess it isn't all THAT boring.
		}
		
		public function getInsertRelationshipIntoMotive(relationshipNetworkID:int, initiatorName:String, responderName:String, otherName:String, motiveToAdd:String, isOtherPerson:Boolean, pred:Predicate ):String {
			//NOW we want to check to see if there is some relationship between the 'ruleRecordOtherName' character, I think?
			var holdingArea:String = "";
			
			var initiatorCharacter:Character = cif.cast.getCharByName(initiatorName);
			var responderCharacter:Character = cif.cast.getCharByName(responderName);
			var otherCharacter:Character = cif.cast.getCharByName(otherName);
			var characterToUse:Character;
			var offCharacter:Character;
			
			var otherNameIndex:int = motiveToAdd.toLowerCase().indexOf(otherName.toLowerCase());
			
			if (otherNameIndex != 0) {
				holdingArea = motiveToAdd.substr(0, otherNameIndex - 1);
			}
			
			if (isOtherPerson) {
				characterToUse = responderCharacter;
				offCharacter = initiatorCharacter;
			}
			else {
				characterToUse = initiatorCharacter;
				offCharacter = responderCharacter;
			}
			
			if (RelationshipNetwork.getInstance().getRelationship(relationshipNetworkID, characterToUse, otherCharacter)) {
				if (otherNameIndex == 0) {
					//don't do anything
				}
				else{
					holdingArea = motiveToAdd.substr(0, otherNameIndex - 1);
					holdingArea += " ";
				}
				
				if (pred.type == Predicate.RELATIONSHIP && pred.relationship == relationshipNetworkID) {
					return ""; // This is the ' I am dating my girlfriend Kate' case -- don't return anything.  We just want it to be 'I am dating Kate'
				}
				
				if (RelationshipNetwork.getInstance().getRelationship(relationshipNetworkID, offCharacter, otherCharacter)) {
					holdingArea += "our";
				}
				else if (!isOtherPerson) {
					holdingArea += "my";
				}
				else {
					if (characterToUse.hasTrait(Trait.MALE)) {
						holdingArea += "his";
					}
					else if (characterToUse.hasTrait(Trait.FEMALE)) {
						holdingArea += "her";
					}
					else {
						holdingArea += otherName + "'s"
					}
				}
				
				holdingArea += " ";
				
				if (relationshipNetworkID == RelationshipNetwork.FRIENDS) {
					holdingArea += "friend";
				}
				else if (relationshipNetworkID == RelationshipNetwork.DATING) {
					if (otherCharacter.hasTrait(Trait.MALE)) {
						holdingArea += "boyfriend";
					}
					else if (otherCharacter.hasTrait(Trait.FEMALE)){
						holdingArea += "girlfriend";
					}
					else {
						holdingArea += "date";
					}
				}
				else if (relationshipNetworkID == RelationshipNetwork.ENEMIES) {
					holdingArea += "enemy";
				}
				
				holdingArea += " ";
				
				
				
				if(otherNameIndex < motiveToAdd.length)
					holdingArea += motiveToAdd.substring(otherNameIndex, motiveToAdd.length - 1);
					
				return holdingArea;
			}
			return ""; // return an empty string if wasn't able to find anything.
		}
		
		public function swapInitiatorAndOtherPositionInString(motiveToAdd:String, otherIndex:int, initiatorName:String, otherName:String):String {
			var initiatorIndex:int = motiveToAdd.toLowerCase().indexOf(initiatorName.toLowerCase());
	
			if (motiveToAdd.indexOf(initiatorName + " and " + otherName) != -1) {
				motiveToAdd = StringUtil.replace(motiveToAdd, (initiatorName + " and " + otherName), (otherName + " and I"));
			}
			
			/*
			if (initiatorIndex != -1 && initiatorIndex < otherIndex) {
				//right now we have something like "Oswald and Mave" ... change it to "Mave and Oswald" (so that it will then become "mave and I" instead of "I and Mave"
				var tempString:String = StringUtil.replace(motiveToAdd, otherName, "TEMP###");
				tempString = StringUtil.replace(tempString, initiatorName, otherName);
				tempString = StringUtil.replace(tempString, "TEMP###", "I");
				motiveToAdd = tempString;
			}
			*/
			
			return motiveToAdd; // don't bother with changing any positioning.
		}
		
		
		]]>
	</fx:Script>
		
	
</s:Group>